<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="今天看到一道题：据说是简单的排序题一点简单的思路就是二分查找。。但是1e4*1e4。。emmmm不会代码实现所以还是需要总结一波排序算法的。 常见排序算法分类我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 常见排序算法一般分为以下几种：（1）非线性时间比较类排序：交换类排序（快速排序和冒泡排序）、插入类排序（简单插入排序和希尔排序）、选择类排序（简单选择排序和堆排序）、">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="https://ggzero.github.io/2017/12/17/undefined-title/index.html">
<meta property="og:site_name" content="rigid">
<meta property="og:description" content="今天看到一道题：据说是简单的排序题一点简单的思路就是二分查找。。但是1e4*1e4。。emmmm不会代码实现所以还是需要总结一波排序算法的。 常见排序算法分类我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 常见排序算法一般分为以下几种：（1）非线性时间比较类排序：交换类排序（快速排序和冒泡排序）、插入类排序（简单插入排序和希尔排序）、选择类排序（简单选择排序和堆排序）、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-17T14:07:07.789Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法">
<meta name="twitter:description" content="今天看到一道题：据说是简单的排序题一点简单的思路就是二分查找。。但是1e4*1e4。。emmmm不会代码实现所以还是需要总结一波排序算法的。 常见排序算法分类我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 常见排序算法一般分为以下几种：（1）非线性时间比较类排序：交换类排序（快速排序和冒泡排序）、插入类排序（简单插入排序和希尔排序）、选择类排序（简单选择排序和堆排序）、">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ggzero.github.io/2017/12/17/undefined-title/"/>





  <title>排序算法 | rigid</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">rigid</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I want it all or not at all</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/17/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">排序算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T15:55:45+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>今天看到一道题：<br><a href="http://newoj.acmclub.cn/problems/1123" target="_blank" rel="external">据说是简单的排序题</a><br>一点简单的思路就是二分查找。。但是1e4*1e4。。emmmm不会代码实现<br>所以还是需要总结一波排序算法的。</p>
<h2 id="常见排序算法分类"><a href="#常见排序算法分类" class="headerlink" title="常见排序算法分类"></a><strong>常见排序算法分类</strong></h2><p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。</p>
<p>常见排序算法一般分为以下几种：<br>（1）非线性时间比较类排序：交换类排序（快速排序和冒泡排序）、插入类排序（简单插入排序和希尔排序）、选择类排序（简单选择排序和堆排序）、归并排序（二路归并排序和多路归并排序）；<br>（2）线性时间非比较类排序：计数排序、基数排序和桶排序。</p>
<p>总结：<br>（1）在比较类排序中，归并排序号称最快，其次是快速排序和堆排序，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。<br>（2）线性时间非比较类排序一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要均匀。线性时间非比较类排序的典型特点是以空间换时间。</p>
<p>　有一点我们很容易忽略的是排序算法的稳定性(腾讯校招2016笔试题曾考过)。<br>　　排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。<br>　　对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。<br>　　其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p>
<h1 id="算法描述与实现"><a href="#算法描述与实现" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h1><h2 id="一，交换类排序"><a href="#一，交换类排序" class="headerlink" title="一，交换类排序"></a>一，交换类排序</h2><p>交换排序的基本方法是：两两比较待排序记录的排序码，交换不满足顺序要求的偶对，直到全部满足位置。常见的冒泡排序和快速排序就属于交换类排序。</p>
<p><strong>1，冒泡排序</strong><br>　冒泡排序是一种极其简单的排序算法，它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。<br>　　冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次。<br>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值： n*(n-1)/2。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)         <span class="comment">// 每次最大元素就像气泡一样"浮"到数组的最后</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++) <span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])            <span class="comment">// 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span></div><div class="line">            &#123;</div><div class="line">                Swap(A, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;    <span class="comment">// 从小到大冒泡排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    BubbleSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"冒泡排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2，鸡尾酒排序</strong></p>
<p>　　鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。<br>　　鸡尾酒排序的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;                            <span class="comment">// 初始化边界</span></div><div class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (left &lt; right)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)   <span class="comment">// 前半轮,将最大元素放到后面</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                Swap(A, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right--;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--)   <span class="comment">// 后半轮,将最小元素放到前面</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</div><div class="line">            &#123;</div><div class="line">                Swap(A, i - <span class="number">1</span>, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;   <span class="comment">// 从小到大定向冒泡排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    CocktailSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"鸡尾酒排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3，快速排序</strong><br>　　快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>　　快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：<br>从序列中挑出一个元素，作为”基准”(pivot).<br>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。<br>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。<br>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为<br>n<em>log2n。<br>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：n</em>(n-1)/2。<br><strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong><br>　　快速排序的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 --------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       </span></div><div class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">// 划分函数</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = A[right];               <span class="comment">// 这里每次都选择最后一个元素作为基准</span></div><div class="line">    <span class="keyword">int</span> tail = left - <span class="number">1</span>;                <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)  <span class="comment">// 遍历基准以外的其他元素</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (A[i] &lt;= pivot)              <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></div><div class="line">        &#123;</div><div class="line">            Swap(A, ++tail, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Swap(A, tail + <span class="number">1</span>, right);           <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></div><div class="line">                                        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></div><div class="line">    <span class="keyword">return</span> tail + <span class="number">1</span>;                    <span class="comment">// 返回基准的索引</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> pivot_index = Partition(A, left, right); <span class="comment">// 基准的索引</span></div><div class="line">    QuickSort(A, left, pivot_index - <span class="number">1</span>);</div><div class="line">    QuickSort(A, pivot_index + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;; <span class="comment">// 从小到大快速排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"快速排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二，插入类排序"><a href="#二，插入类排序" class="headerlink" title="二，插入类排序"></a>二，插入类排序</h2><p><strong>1，直接插入排序</strong><br>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。　对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。<br>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>　　具体算法描述如下：
　　</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li><p>重复步骤2~5</p>
<p>最好情况：当待排序记录已经有序，这时需要比较的次数是n-1；<br>最坏情况：如果待排序记录为逆序，则最多的比较次数为n*(n-1)/2;<br>插入排序的代码如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></div><div class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></div><div class="line">        &#123;</div><div class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;<span class="comment">// 从小到大插入排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    InsertionSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"插入排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>
<p><strong>2,二分插入排序</strong><br>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></div><div class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></div><div class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></div><div class="line">        &#123;</div><div class="line">            A[j + <span class="number">1</span>] = A[j];</div><div class="line">        &#125;</div><div class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大二分插入排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    InsertionSortDichotomy(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"二分插入排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<p><strong>3，Shell排序</strong></p>
<p>　　希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。<br>　　Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按d(i−1)分组排序，文件接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。<br>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。<br>　　希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li><p>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p>
<p>　　希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>　　假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>　　<strong>希尔排序是不稳定的排序算法</strong>，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。<br>　　Shell排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值比较合理，Shell排序算法的时间复杂度约为n^1.3。<br>　　对于增量的选择，Shell 最初建议增量选择为n/2，并且对增量取半直到 1；D. Knuth教授建议d(i+1)=[d(i-1)/3]序列。<br>　　希尔排序的代码如下：
　　</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (h &lt;= n)                          <span class="comment">// 生成初始增量</span></div><div class="line">    &#123;</div><div class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> j = i - h;</div><div class="line">            <span class="keyword">int</span> get = A[i];</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</div><div class="line">            &#123;</div><div class="line">                A[j + h] = A[j];</div><div class="line">                j = j - h;</div><div class="line">            &#125;</div><div class="line">            A[j + h] = get;</div><div class="line">        &#125;</div><div class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大希尔排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    ShellSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"希尔排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三，选择类排序"><a href="#三，选择类排序" class="headerlink" title="三，选择类排序"></a>三，选择类排序</h2><p>选择类排序的基本方法是：每步从待排序记录中选出排序码最小的记录，顺序放在已排序的记录序列的后面，知道全部排完。<br><strong>1，简单选择排序</strong><br>　　选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。<br>　　因简单选择排序也是常见排序算法中性能最差的排序算法。简单选择排序的比较次数与文件的初始状态没有关系，在第i趟排序中选出最小排序码的记录，需要做n-i次比较，因此总的比较次数是n<em>(n-1)/2。<br>　　<em>*选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</em></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></div><div class="line">            &#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (min != i)</div><div class="line">        &#123;</div><div class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span> &#125;; <span class="comment">// 从小到大选择排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    SelectionSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"选择排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2，堆排序</strong><br>　　鉴于。。我们都不怎么熟悉堆，先来讨论一下堆：<br>　<br>　　<strong>关于堆：</strong><br>　　（1）性质：完全二叉树或者是近似完全二叉树；<br>　　（2）分类：大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值；<br>　　（3）左右孩子：没有大小的顺序。<br>　　（4）堆的存储 ：一般都用数组来存储堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为 2\∗i+1和 2\∗i+2。<br>　　<strong>（5）堆的操作</strong> </p>
<p>　　<strong><1>插入：</1></strong> 将一个新元素插入到表尾，即数组末尾时，如果新构成的二叉树不满足堆的性质，需要重新排列元素。<br>　　每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中，这就类似于直接插入排序中将一个数据并入到有序区间中，这是节点“上浮”调整。不难写出插入一个新数据时堆的调整代码：
　　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新加入i结点,其父结点为(i-1)/2</span></div><div class="line"><span class="comment">//参数：a：数组，i：新插入元素在数组中的下标  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">minHeapFixUp</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> j, temp;  </div><div class="line">    temp = a[i];  </div><div class="line">    j = (i<span class="number">-1</span>)/<span class="number">2</span>;      <span class="comment">//父结点  </span></div><div class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span> (a[j] &lt;= temp)<span class="comment">//如果父节点不大于新插入的元素，停止寻找  </span></div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        a[i]=a[j];     <span class="comment">//把较大的子结点往下移动,替换它的子结点  </span></div><div class="line">        i = j;  </div><div class="line">        j = (i<span class="number">-1</span>)/<span class="number">2</span>;  </div><div class="line">    &#125;  </div><div class="line">    a[i] = temp;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，插入数据到最小堆时：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在最小堆中加入新的数据data  </span></div><div class="line"><span class="comment">//a：数组，index：插入的下标，</span></div><div class="line"><span class="keyword">void</span> minHeapAddNumber(<span class="keyword">int</span> a[], <span class="keyword">int</span> <span class="keyword">index</span>, <span class="keyword">int</span> data)  </div><div class="line">&#123;  </div><div class="line">    a[<span class="keyword">index</span>] = data;  </div><div class="line">    minHeapFixUp(a, <span class="keyword">index</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong><2>删除：</2></strong><br>　　堆排序中，删除一个元素总是发生在堆顶，因为堆顶的元素是最小的（小顶堆中）。表中最后一个元素用来填补空缺位置，结果树被更新以满足堆条件。</p>
<p>　　按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将数组最后一个数据与根结点，然后再从根结点开始进行一次从上向下的调整。<br>　　调整时先在左右儿子结点中找最小的，如果父结点不大于这个最小的子结点说明不需要调整了，反之将最小的子节点换到父结点的位置。此时父节点实际上并不需要换到最小子节点的位置，因为这不是父节点的最终位置。但逻辑上父节点替换了最小的子节点，然后再考虑父节点对后面的结点的影响。相当于从根结点将一个数据的“下沉”过程。下面给出代码：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a为数组，从index节点开始调整,len为节点总数 从0开始计算index节点的子节点为 2*index+1, 2*index+2,len/2-1为最后一个非叶子节点  </span></div><div class="line"><span class="keyword">void</span> minHeapFixDown(<span class="keyword">int</span> a[],<span class="keyword">int</span> len,<span class="keyword">int</span> <span class="keyword">index</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">index</span>&gt;(len/<span class="number">2</span><span class="number">-1</span>))<span class="comment">//index为叶子节点不用调整</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> tmp=a[<span class="keyword">index</span>];</div><div class="line">    <span class="keyword">int</span> lastIndex=<span class="keyword">index</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">index</span>&lt;=(len/<span class="number">2</span><span class="number">-1</span>))&#123; <span class="comment">//当下沉到叶子节点时，就不用调整了</span></div><div class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>]&lt;tmp) <span class="comment">//如果左子节点大于该节点</span></div><div class="line">            lastIndex = <span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>;</div><div class="line">        <span class="comment">//如果存在右子节点且大于左子节点和该节点</span></div><div class="line">        <span class="keyword">if</span>(<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>&lt;len &amp;&amp; a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>]&lt;a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>]&amp;&amp; a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>]&lt;tmp)</div><div class="line">            lastIndex = <span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(lastIndex!=<span class="keyword">index</span>)&#123;  <span class="comment">//如果左右子节点有一个小于该节点则设置该节点的下沉位置</span></div><div class="line">            a[<span class="keyword">index</span>]=a[lastIndex];</div><div class="line">            <span class="keyword">index</span>=lastIndex;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">//否则该节点不用下沉调整</span></div><div class="line">    &#125;</div><div class="line">    a[lastIndex]=tmp;<span class="comment">//将该节点放到最后的位置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong><3>建堆：</3></strong><br>　　有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！
　　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立最小堆</span></div><div class="line"><span class="comment">//a:数组，n：数组长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeMinHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">        minHeapFixDown(a, i, n);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。<br>　　我们可以很容易的定义堆排序的过程：
　　</p>
<ul>
<li>由输入的无序数组构造一个最大堆，作为初始的无序区</li>
<li>把堆顶元素（最大值）和堆尾元素互换</li>
<li>把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整</li>
<li><p>重复步骤2，直到堆的尺寸为1</p>
<p><strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> Swap(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Heapify(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> <span class="built_in">size</span>)  <span class="comment">// 从A[i]向下进行堆调整</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></div><div class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></div><div class="line">    <span class="built_in">if</span> (left_child &lt; <span class="built_in">size</span> &amp;&amp; A[left_child] &gt; A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span> = left_child;</div><div class="line">    <span class="built_in">if</span> (right_child &lt; <span class="built_in">size</span> &amp;&amp; A[right_child] &gt; A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span> = right_child;</div><div class="line">    <span class="built_in">if</span> (<span class="built_in">max</span> != i)</div><div class="line">    &#123;</div><div class="line">        Swap(A, i, <span class="built_in">max</span>);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></div><div class="line">        Heapify(A, <span class="built_in">max</span>, <span class="built_in">size</span>);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> BuildHeap(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)           <span class="comment">// 建堆，时间复杂度O(n)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = n;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></div><div class="line">        Heapify(A, i, heap_size);</div><div class="line">    <span class="built_in">return</span> heap_size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></div><div class="line">    <span class="built_in">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></div><div class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></div><div class="line">        Swap(A, <span class="number">0</span>, --heap_size);</div><div class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大堆排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    HeapSort(A, n);</div><div class="line">    printf(<span class="string">"堆排序结果："</span>);</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong>堆排序的性能分析</strong><br>由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次堆调整操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。两次次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。<br>最坏情况：如果待排序数组是有序的，仍然需要O(N * logN)复杂度的比较操作，只是少了移动的操作；<br>最好情况：如果待排序数组是逆序的，不仅需要O(N * logN)复杂度的比较操作，而且需要O(N * logN)复杂度的交换操作。总的时间复杂度还是O(N * logN)。<br>因此，堆排序和快速排序在效率上是差不多的，但是堆排序一般优于快速排序的重要一点是，数据的初始分布情况对堆排序的效率没有大的影响。</p>
<h2 id="四，归并排序"><a href="#四，归并排序" class="headerlink" title="四，归并排序"></a>四，归并排序</h2><p>　　归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。<br>　　归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。<br>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：
　　</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;limits.h&gt;</div><div class="line"></div><div class="line">// 分类 -------------- 内部比较排序</div><div class="line">// 数据结构 ---------- 数组</div><div class="line">// 最差时间复杂度 ---- O(nlogn)</div><div class="line">// 最优时间复杂度 ---- O(nlogn)</div><div class="line">// 平均时间复杂度 ---- O(nlogn)</div><div class="line">// 所需辅助空间 ------ O(<span class="built_in">n</span>)</div><div class="line">// 稳定性 ------------ 稳定</div><div class="line"></div><div class="line"></div><div class="line">void Merge(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)// 合并两个已排好序的数组A[left...mid]和A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = <span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span> *temp = new <span class="built_in">int</span>[<span class="built_in">len</span>];       // 辅助空间O(<span class="built_in">n</span>)</div><div class="line">    <span class="built_in">int</span> <span class="built_in">index</span> = <span class="number">0</span>;</div><div class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>;                   // 前一数组的起始元素</div><div class="line">    <span class="built_in">int</span> j = <span class="built_in">mid</span> + <span class="number">1</span>;                // 后一数组的起始元素</div><div class="line">    while (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[i] &lt;= A[j] ? A[i++] <span class="symbol">:</span> A[j++];  // 带等号保证归并排序的稳定性</div><div class="line">    &#125;</div><div class="line">    while (i &lt;= <span class="built_in">mid</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[i++];</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= <span class="built_in">right</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[j++];</div><div class="line">    &#125;</div><div class="line">    for (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>; k++)</div><div class="line">    &#123;</div><div class="line">        A[<span class="built_in">left</span>++] = temp[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void MergeSortRecursion(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)    // 递归实现的归并排序(自顶向下)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">if</span> (<span class="built_in">left</span> == <span class="built_in">right</span>)    // 当待排序的序列长度为<span class="number">1</span>时，递归开始回溯，进行merge操作</div><div class="line">        return;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</div><div class="line">    MergeSortRecursion(A, <span class="built_in">left</span>, <span class="built_in">mid</span>);</div><div class="line">    MergeSortRecursion(A, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</div><div class="line">    Merge(A, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void MergeSortIteration(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">len</span>)    // 非递归(迭代)实现的归并排序(自底向上)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">len</span>; i *= <span class="number">2</span>)        // 子数组的大小i初始为<span class="number">1</span>，每轮翻倍</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">left</span> = <span class="number">0</span>;</div><div class="line">        while (<span class="built_in">left</span> + i &lt; <span class="built_in">len</span>)              // 后一个子数组存在(需要归并)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">mid</span> = <span class="built_in">left</span> + i - <span class="number">1</span>;</div><div class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span> + i &lt; <span class="built_in">len</span> ? <span class="built_in">mid</span> + i <span class="symbol">:</span> <span class="built_in">len</span> - <span class="number">1</span>;// 后一个子数组大小可能不够</div><div class="line">            Merge(A, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</div><div class="line">            <span class="built_in">left</span> = <span class="built_in">right</span> + <span class="number">1</span>;               // 前一个子数组索引向后移动</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="symbol">A1</span>[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;      // 从小到大归并排序</div><div class="line">    <span class="built_in">int</span> <span class="symbol">A2</span>[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="built_in">int</span> <span class="symbol">n1</span> = sizeof(<span class="symbol">A1</span>) / sizeof(<span class="built_in">int</span>);</div><div class="line">    <span class="built_in">int</span> <span class="symbol">n2</span> = sizeof(<span class="symbol">A2</span>) / sizeof(<span class="built_in">int</span>);</div><div class="line">    MergeSortRecursion(<span class="symbol">A1</span>, <span class="number">0</span>, <span class="symbol">n1</span> - <span class="number">1</span>);          // 递归实现</div><div class="line">    MergeSortIteration(<span class="symbol">A2</span>, <span class="symbol">n2</span>);                 // 非递归实现</div><div class="line">    printf(<span class="string">"递归实现的归并排序结果："</span>);</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="symbol">n1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, <span class="symbol">A1</span>[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"非递归实现的归并排序结果："</span>);</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="symbol">n2</span>; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, <span class="symbol">A2</span>[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="五，非比较排序"><a href="#五，非比较排序" class="headerlink" title="五，非比较排序"></a>五，非比较排序</h2><p><strong>1.计数排序</strong><br>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出，它的优势在于在对于较小范围内的整数排序。它的复杂度为Ο(n+k)（其中k是待排序数的范围），快于任何比较排序算法，缺点就是非常消耗空间。很明显，如果而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序，比如堆排序和归并排序和快速排序。<br>算法原理：<br>基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，在代码中作适当的修改即可。<br>算法步骤：<br>（1）找出待排序的数组中最大的元素；<br>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<br>时间复杂度：Ο(n+k)。<br>空间复杂度：Ο(k)。<br>要求：待排序数中最大数值不能太大。<br>稳定性：稳定。<br>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 20    <span class="comment">//待排序数的最大个数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX    100   <span class="comment">//待排序数的最大值</span></span></div><div class="line"><span class="keyword">int</span> sorted_arr[MAXNUM]=&#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//计算排序</span></div><div class="line"><span class="comment">//arr:待排序数组，sorted_arr：排好序的数组，n：待排序数组长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> *sorted_arr, <span class="keyword">int</span> n)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> i;   </div><div class="line">    <span class="keyword">int</span> *count_arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX+<span class="number">1</span>));  </div><div class="line"></div><div class="line">    <span class="comment">//初始化计数数组   </span></div><div class="line">    <span class="built_in">memset</span>(count_arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX+<span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="comment">//统计i的次数   </span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n;i++)  </div><div class="line">        count_arr[arr[i]]++;  </div><div class="line">    <span class="comment">//对所有的计数累加，作用是统计arr数组值和小于小于arr数组值出现的个数</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=MAX; i++)  </div><div class="line">        count_arr[i] += count_arr[i<span class="number">-1</span>];   </div><div class="line">    <span class="comment">//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到新的数组中   </span></div><div class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//count_arr[arr[i]]表示arr数组中包括arr[i]和小于arr[i]的总数</span></div><div class="line">        sorted_arr[count_arr[arr[i]]<span class="number">-1</span>] = arr[i];  </div><div class="line"></div><div class="line">        <span class="comment">//如果arr数组中有相同的数，arr[i]的下标减一</span></div><div class="line">        count_arr[arr[i]]--;    </div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(count_arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：计数排序是典型的以空间换时间的排序算法，对待排序的数据有严格的要求，比如待排序的数值中不能包含负数，最大值也有限制，请谨慎使用。<br><strong>2.基数排序</strong><br>基数排序属于“分配式排序”（distribution sort），是非比较类线性时间排序的一种，又称“桶子法”（bucket sort）。顾名思义，它是透过键值的部分信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。<br>基数排序（以整形为例），将整形10进制按每位拆分，然后从低位到高位依次比较各个位。主要分为两个过程：<br>　　(1)分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中（比如６4，个位为４，则放入４号桶中）；<br>　　(2)收集，再将放置在0~9号桶中的数据按顺序放到数组中；<br>　　重复(1)(2)过程，从个位到最高位（比如32位无符号整形最大数4294967296，最高位为第10位）。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<br>　　平均时间复杂度：O(dn)(d即表示整形的最高位数)。<br>　　空间复杂度：O(10n) （10表示0~9，用于存储临时的序列） 。<br>　　稳定性：稳定。<br>　<br>（1）MSD法实现<br>最高位优先法通常是一个递归的过程：</p>
<p><1>先根据最高位关键码K1排序，得到若干对象组，对象组中每个对象都有相同关键码K1。 </1></p>
<p><2>再分别对每组中对象根据关键码K2进行排序，按K2值的不同，再分成若干个更小的子组，每个子组中的对象具有相同的K1和K2值。</2></p>
<p><3>依此重复，直到对关键码Kd完成排序为止。</3></p>
<p><4> 最后，把所有子组中的对象依次连接起来，就得到一个有序的对象序列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdigit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;     <span class="comment">//因为待排数据最大数据也只是两位数，所以在此只需要到十位就满足</span></div><div class="line">    <span class="keyword">return</span> ((x / a[d]) % <span class="number">10</span>);    <span class="comment">//确定桶号</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintArr</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ar[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msdradix_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;     </div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> radix = <span class="number">10</span>;   </div><div class="line">    <span class="keyword">int</span> count[radix], i, j; </div><div class="line">    <span class="comment">//置空</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; radix; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[i] = <span class="number">0</span>;   </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//分配桶存储空间</span></div><div class="line">    <span class="keyword">int</span> *bucket = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((end-begin+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    </div><div class="line">    <span class="comment">//统计各桶需要装的元素的个数  </span></div><div class="line">    <span class="keyword">for</span>(i = begin;i &lt;= end; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[getdigit(arr[i], d)]++;   </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求出桶的边界索引，count[i]值为第i个桶的右边界索引+1</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[i] = count[i] + count[i<span class="number">-1</span>];    </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里要从右向左扫描，保证排序稳定性 </span></div><div class="line">    <span class="keyword">for</span>(i = end;i &gt;= begin; --i)          </div><div class="line">    &#123;    </div><div class="line">        j = getdigit(arr[i], d);      <span class="comment">//求出关键码的第d位的数字， 例如：576的第3位是5   </span></div><div class="line">        bucket[count[j]<span class="number">-1</span>] = arr[i];   <span class="comment">//放入对应的桶中，count[j]-1是第j个桶的右边界索引   </span></div><div class="line">        --count[j];                    <span class="comment">//第j个桶放下一个元素的位置(右边界索引+1)   </span></div><div class="line">    &#125;   </div><div class="line">    <span class="comment">//注意：此时count[i]为第i个桶左边界    </span></div><div class="line">    <span class="comment">//从各个桶中收集数据  </span></div><div class="line">    <span class="keyword">for</span>(i = begin, j = <span class="number">0</span>;i &lt;= end; ++i, ++j)  </div><div class="line">    &#123;</div><div class="line">        arr[i] = bucket[j]; </div><div class="line">    &#125;       </div><div class="line">    <span class="comment">//释放存储空间</span></div><div class="line">    <span class="built_in">free</span>(bucket);   </div><div class="line">    <span class="comment">//对各桶中数据进行再排序</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; radix; i++)  </div><div class="line">    &#123;   </div><div class="line">        <span class="keyword">int</span> p1 = begin + count[i];         <span class="comment">//第i个桶的左边界   </span></div><div class="line">        <span class="keyword">int</span> p2 = begin + count[i+<span class="number">1</span>]<span class="number">-1</span>;     <span class="comment">//第i个桶的右边界   </span></div><div class="line">        <span class="keyword">if</span>(p1 &lt; p2 &amp;&amp; d &gt; <span class="number">1</span>)  </div><div class="line">        &#123;</div><div class="line">            msdradix_sort(arr, p1, p2, d<span class="number">-1</span>);  <span class="comment">//对第i个桶递归调用，进行基数排序，数位降 1    </span></div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>  ar[] = &#123;<span class="number">12</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">47</span>, <span class="number">89</span>&#125;;</div><div class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序前数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(ar, len);</div><div class="line">    msdradix_sort(ar, <span class="number">0</span>, len<span class="number">-1</span>, <span class="number">2</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后结果如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(ar, len);</div><div class="line">&#125; </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">排序前数据如下：</span></div><div class="line"><span class="comment">12 14 54 5 6 3 9 8 47 89</span></div><div class="line"><span class="comment">排序后结果如下：</span></div><div class="line"><span class="comment">3 5 6 8 9 12 14 47 54 89</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></4></p>
<p>（2）LSD法实现<br>最低位优先法首先依据最低位关键码Kd对所有对象进行一趟排序，<br>再依据次低位关键码Kd-1对上一趟排序的结果再排序，<br>依次重复，直到依据关键码K1最后一趟排序完成，就可以得到一个有序的序列。<br>使用这种排序方法对每一个关键码进行排序时，不需要再分组，而是整个对象组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>   MAXSIZE   10000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdigit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>&#125;;   <span class="comment">//最大三位数，所以这里只要百位就满足了。</span></div><div class="line">    <span class="keyword">return</span> (x/a[d]) % <span class="number">10</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintArr</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ar[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsdradix_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> radix = <span class="number">10</span>;   </div><div class="line">    <span class="keyword">int</span> count[radix], i, j; </div><div class="line"></div><div class="line">    <span class="keyword">int</span> *bucket = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((end-begin+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">//所有桶的空间开辟   </span></div><div class="line">   </div><div class="line">    <span class="comment">//按照分配标准依次进行排序过程</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; ++k)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//置空</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; radix; i++)  </div><div class="line">        &#123;</div><div class="line">            count[i] = <span class="number">0</span>;        </div><div class="line">        &#125;               </div><div class="line">        <span class="comment">//统计各个桶中所盛数据个数</span></div><div class="line">        <span class="keyword">for</span>(i = begin; i &lt;= end; i++) </div><div class="line">        &#123;</div><div class="line">           count[getdigit(arr[i], k)]++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//count[i]表示第i个桶的右边界索引</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++) </div><div class="line">        &#123;</div><div class="line">            count[i] = count[i] + count[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把数据依次装入桶(注意装入时候的分配技巧)</span></div><div class="line">        <span class="keyword">for</span>(i = end;i &gt;= begin; --i)        <span class="comment">//这里要从右向左扫描，保证排序稳定性   </span></div><div class="line">        &#123;    </div><div class="line">            j = getdigit(arr[i], k);        <span class="comment">//求出关键码的第k位的数字， 例如：576的第3位是5   </span></div><div class="line">            bucket[count[j]<span class="number">-1</span>] = arr[i]; <span class="comment">//放入对应的桶中，count[j]-1是第j个桶的右边界索引 </span></div><div class="line">            --count[j];               <span class="comment">//对应桶的装入数据索引减一  </span></div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">//注意：此时count[i]为第i个桶左边界  </span></div><div class="line">        </div><div class="line">        <span class="comment">//从各个桶中收集数据</span></div><div class="line">        <span class="keyword">for</span>(i = begin,j = <span class="number">0</span>; i &lt;= end; ++i, ++j)  </div><div class="line">        &#123;</div><div class="line">            arr[i] = bucket[j];    </div><div class="line">        &#125;        </div><div class="line">    &#125;     </div><div class="line">    <span class="built_in">free</span>(bucket);   </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>  br[<span class="number">10</span>] = &#123;<span class="number">20</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">589</span>, <span class="number">998</span>, <span class="number">965</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>&#125;;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"原数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(br,<span class="number">10</span>);</div><div class="line">    lsdradix_sort(br, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(br, <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">原数据如下：</span></div><div class="line"><span class="comment">20 80 90 589 998 965 852 123 456 789</span></div><div class="line"><span class="comment">排序后数据如下：</span></div><div class="line"><span class="comment">20 80 90 123 456 589 789 852 965 998</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p><strong>3.桶排序</strong><br>桶排序也是分配排序的一种，但其是基于比较排序的，这也是与基数排序最大的区别所在。<br>思想：桶排序算法想法类似于散列表。首先要假设待排序的元素输入符合某种均匀分布，例如数据均匀分布在[ 0,1）区间上，则可将此区间划分为10个小区间，称为桶，对散布到同一个桶中的元素再排序。<br>要求：待排序数长度一致。<br>排序过程：<br>（1）设置一个定量的数组当作空桶子；<br>（2）寻访序列，并且把记录一个一个放到对应的桶子去；<br>（3）对每个不是空的桶子进行排序。<br>（4）从不是空的桶子里把项目再放回原来的序列中。<br>时间复杂度：<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，对于N个待排数据，M个桶，平均每个桶[N/M]个数据，则桶内排序的时间复杂度为O(N*log2(N/M))。<br>因此，平均时间复杂度为线性的O(N+C)，C为桶内排序所花费的时间。当每个桶只有一个数，则最好的时间复杂度为：O(N)。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line"> &#123; </div><div class="line">     int keyNum;<span class="comment">//桶中数的数量</span></div><div class="line">     int key;   <span class="comment">//存储的元素</span></div><div class="line">     struct node * next;  </div><div class="line"> &#125;KeyNode;    </div><div class="line"></div><div class="line"> <span class="comment">//keys待排序数组，size数组长度，bucket_size桶的数量</span></div><div class="line"> void inc_sort(int keys[],int size,int bucket_size)</div><div class="line"> &#123; </div><div class="line">     KeyNode* k=(KeyNode *)malloc(sizeof(KeyNode)); <span class="comment">//用于控制打印</span></div><div class="line">     int i,j,b;</div><div class="line">     KeyNode **bucket_table=(KeyNode **)malloc(bucket_size*sizeof(KeyNode *)); </div><div class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bucket_size;i++)</div><div class="line">     &#123;  </div><div class="line">         bucket_table[i]=(KeyNode *)malloc(sizeof(KeyNode)); </div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>keyNum=<span class="number">0</span>;<span class="comment">//记录当前桶中是否有数据</span></div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>key=<span class="number">0</span>;   <span class="comment">//记录当前桶中的数据  </span></div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>next=NULL; </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">     <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)</div><div class="line">     &#123;   </div><div class="line">         int index;</div><div class="line">         KeyNode *p;</div><div class="line">         KeyNode *node=(KeyNode *)malloc(sizeof(KeyNode));   </div><div class="line">         <span class="function"><span class="title">node</span>-&gt;</span>key=keys[j];  </div><div class="line">         <span class="function"><span class="title">node</span>-&gt;</span>next=NULL;  </div><div class="line"></div><div class="line">         index=keys[j]/<span class="number">10</span>;        <span class="comment">//映射函数计算桶号  </span></div><div class="line">         p=bucket_table[index];   <span class="comment">//初始化P成为桶中数据链表的头指针  </span></div><div class="line">         <span class="function"><span class="title">if</span>(p-&gt;</span>keyNum==<span class="number">0</span>)<span class="comment">//该桶中还没有数据 </span></div><div class="line">         &#123;    </div><div class="line">             <span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>next=node;    </div><div class="line">             (<span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>keyNum)++;  <span class="comment">//桶的头结点记录桶内元素各数，此处加一</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span><span class="comment">//该桶中已有数据 </span></div><div class="line">         &#123;   </div><div class="line">             <span class="comment">//链表结构的插入排序 </span></div><div class="line">             <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">next</span>!=NULL&amp;&amp;p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">key</span>&lt;=node-&gt;</span>key)   </div><div class="line">                 <span class="function"><span class="title">p</span>=p-&gt;</span>next;    </div><div class="line">             <span class="function"><span class="title">node</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span>next;     </div><div class="line">             <span class="function"><span class="title">p</span>-&gt;</span>next=node;      </div><div class="line">             (<span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>keyNum)++;   </div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//打印结果</span></div><div class="line">     <span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;bucket_size;b++)   </div><div class="line">         <span class="comment">//判断条件是跳过桶的头结点，桶的下个节点为元素节点不为空</span></div><div class="line">         <span class="function"><span class="title">for</span>(k=bucket_table[b];k-&gt;</span><span class="function"><span class="title">next</span>!=NULL;k=k-&gt;</span>next)  </div><div class="line">         &#123;</div><div class="line">             <span class="function"><span class="title">printf</span>("%d ",k-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>key);</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>开头那道题的题解。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="keyword">int</span> b[maxn];</div><div class="line"><span class="keyword">int</span> m, n, k;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (l &lt;= r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (b[mid] &lt;= x)</div><div class="line">            l = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            r = mid - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ll ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">    &#123;</div><div class="line">            <span class="keyword">if</span> (!a[i])<span class="comment">// 如果a[i] 是0的话 那么这一排m必取</span></div><div class="line">            &#123;</div><div class="line">                ans += n;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> cnt = x / a[i];<span class="comment">//a[i]* cnt=x; 求最大的cnt 其他比</span></div><div class="line">            <span class="comment">//cnt小的 都要加起来</span></div><div class="line">            ans += getsum(cnt);<span class="comment">//在b里找 比cnt小的</span></div><div class="line">    &#125;</div><div class="line">     <span class="keyword">return</span> ans &gt;= k;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;m,&amp;n,&amp;k);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</div><div class="line">    sort(a,a+m);</div><div class="line">    sort(b,b+n);</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> r = a[m<span class="number">-1</span>]*b[n<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(l&lt;=r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</div><div class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在C++的STL中封装了一个叫优先队列的东西，它的实现原理和堆非常类似，可以直接使用。<br><strong>优先队列</strong>：<br>顾名思义，首先它是一个队列，但是它强调了“优先”二字，所以，已经不能算是一般意义上的队列了，它的“优先”意指取队首元素时，有一定的选择性，即根据元素的属性选择某一项值最优的出队~<br>百度百科上这样描述的：<br>　　优先级队列 是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素<br>　　优先队列的类定义　　<br>　　优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.<br>其声明格式为：priority_queue <int> ans;//声明一个名为ans的整形的优先队列<br>基本操作有：<br>empty( )  //判断一个队列是否为空<br>pop( )  //删除队顶元素<br>push( )  //加入一个元素<br>size( )  //返回优先队列中拥有的元素个数<br>top( )  //返回优先队列的队顶元素</int></p>
<p>优先队列的时间复杂度为O（logn），n为队列中元素的个数，其存取都需要时间。</p>
<p>在默认的优先队列中，优先级最高的先出队。默认的int类型的优先队列中先出队的为队列中较大的数。</p>
<p>然而更多的情况下，我们是希望可以自定义其优先级的，下面介绍几种常用的定义优先级的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*优先队列的基本使用    2010/7/24    dooder*/</span>  </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">//定义结构，使用运算符重载,自定义优先级1  </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span>  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span>  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> a&lt;b;<span class="comment">//最大值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="comment">//定义结构，使用运算符重载,自定义优先级2  </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number1</span>&#123;</span>  </div><div class="line">    <span class="keyword">int</span> x;  </div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;  </div><div class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number2</span>&#123;</span>  </div><div class="line">    <span class="keyword">int</span> x;  </div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number2 &amp;a) <span class="keyword">const</span> &#123;  </div><div class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//最大值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">number1 num1[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">number2 num2[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;   priority_queue&lt;<span class="keyword">int</span>&gt;que;<span class="comment">//采用默认优先级构造队列  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先  </span></div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;que2;<span class="comment">//最大值优先  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，  </span></div><div class="line">                                                      <span class="comment">//这是右移运算符，所以这里用空格号隔开  </span></div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;que4;<span class="comment">////最大值优先  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;number1&gt;que5;  </div><div class="line">    priority_queue&lt;number2&gt;que6;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;a[i];i++)&#123;  </div><div class="line">        que.push(a[i]);  </div><div class="line">        que1.push(a[i]);  </div><div class="line">        que2.push(a[i]);  </div><div class="line">        que3.push(a[i]);  </div><div class="line">        que4.push(a[i]);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;num1[i].x;i++)  </div><div class="line">        que5.push(num1[i]);  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;num2[i].x;i++)  </div><div class="line">        que6.push(num2[i]);  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用默认优先关系:\n(priority_queue&lt;int&gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 0:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que.top());  </div><div class="line">        que.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用结构体自定义优先级方式一:\n(priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 1:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que1.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que1.top());  </div><div class="line">        que1.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 2:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que2.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que2.top());  </div><div class="line">        que2.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用头文件\"functional\"内定义优先级:\n(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;/less&lt;int&gt; &gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 3:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que3.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que3.top());  </div><div class="line">        que3.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 4:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que4.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que4.top());  </div><div class="line">        que4.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用结构体自定义优先级方式二:\n(priority_queue&lt;number&gt;que)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 5:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que5.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que5.top());  </div><div class="line">        que5.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 6:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que6.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que6.top());  </div><div class="line">        que6.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment">运行结果 ： </span></div><div class="line"><span class="comment">采用默认优先关系: </span></div><div class="line"><span class="comment">(priority_queue&lt;int&gt;que;) </span></div><div class="line"><span class="comment">Queue 0: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用结构体自定义优先级方式一: </span></div><div class="line"><span class="comment">(priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;que;) </span></div><div class="line"><span class="comment">Queue 1: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 2: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用头文件"functional"内定义优先级: </span></div><div class="line"><span class="comment">(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;/less&lt;int&gt; &gt;que;) </span></div><div class="line"><span class="comment">Queue 3: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 4: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用结构体自定义优先级方式二: </span></div><div class="line"><span class="comment">(priority_queue&lt;number&gt;que) </span></div><div class="line"><span class="comment">Queue 5: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 6: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment">*/</span>  </div><div class="line">运行结果：</div><div class="line">采用默认优先关系:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>&gt;que;)</div><div class="line">Queue <span class="number">0</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用结构体自定义优先级方式一:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp&gt;que;)</div><div class="line">Queue <span class="number">1</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">2</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用头文件<span class="string">"functional"</span>内定义优先级:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;/less&lt;<span class="keyword">int</span>&gt; &gt;que;)</div><div class="line">Queue <span class="number">3</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">4</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用结构体自定义优先级方式二:</div><div class="line">(priority_queue&lt;number&gt;que)</div><div class="line">Queue <span class="number">5</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">6</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div></pre></td></tr></table></figure>
<p>引用：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/eniac12/p/5329396.html#s4" target="_blank" rel="external">https://www.cnblogs.com/eniac12/p/5329396.html#s4</a><br><a href="http://blog.csdn.net/k346k346/article/details/50791102" target="_blank" rel="external">http://blog.csdn.net/k346k346/article/details/50791102</a><br><a href="https://www.cnblogs.com/Braveliu/archive/2013/01/21/2870201.html" target="_blank" rel="external">https://www.cnblogs.com/Braveliu/archive/2013/01/21/2870201.html</a><br><a href="http://blog.csdn.net/qq_36553623/article/details/72809695" target="_blank" rel="external">http://blog.csdn.net/qq_36553623/article/details/72809695</a><br><a href="http://www.cnblogs.com/heqinghui/archive/2013/07/30/3225407.html" target="_blank" rel="external">http://www.cnblogs.com/heqinghui/archive/2013/07/30/3225407.html</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/15/undefined-title/" rel="next" title="818">
                <i class="fa fa-chevron-left"></i> 818
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/31/undefined-title/" rel="prev" title="2017">
                2017 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="zero.G" />
            
              <p class="site-author-name" itemprop="name">zero.G</p>
              <p class="site-description motion-element" itemprop="description">败者无荣耀</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yourname" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见排序算法分类"><span class="nav-number">1.</span> <span class="nav-text">常见排序算法分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法描述与实现"><span class="nav-number"></span> <span class="nav-text">算法描述与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一，交换类排序"><span class="nav-number">1.</span> <span class="nav-text">一，交换类排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二，插入类排序"><span class="nav-number">2.</span> <span class="nav-text">二，插入类排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三，选择类排序"><span class="nav-number">3.</span> <span class="nav-text">三，选择类排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四，归并排序"><span class="nav-number">4.</span> <span class="nav-text">四，归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五，非比较排序"><span class="nav-number">5.</span> <span class="nav-text">五，非比较排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#番外"><span class="nav-number">6.</span> <span class="nav-text">番外</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zero.G</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
