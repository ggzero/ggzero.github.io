<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="败者无荣耀">
<meta property="og:type" content="website">
<meta property="og:title" content="rigid">
<meta property="og:url" content="https://ggzero.github.io/index.html">
<meta property="og:site_name" content="rigid">
<meta property="og:description" content="败者无荣耀">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rigid">
<meta name="twitter:description" content="败者无荣耀">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ggzero.github.io/"/>





  <title>rigid</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">rigid</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I want it all or not at all</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/31/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/31/undefined-title/" itemprop="url">2017</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-31T23:25:54+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>人还是有些健忘的。<br>从很难接受到坦然面对原来只需要<br>其实不幸也是幸运。<br>一念天堂。<br>哦，那两年呢。<br>现在这样又算是什么？<br>妄想总是因为其戳中人性弱点的特性备受青睐。<br>再两年呢。<br>有点捡不动了。<br>要不要放弃呢？<br>今夜我不关心算法。<br>2018</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"May the flame guide thee."</span>)</span></span></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/17/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/undefined-title/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T15:55:45+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天看到一道题：<br><a href="http://newoj.acmclub.cn/problems/1123" target="_blank" rel="external">据说是简单的排序题</a><br>一点简单的思路就是二分查找。。但是1e4*1e4。。emmmm不会代码实现<br>所以还是需要总结一波排序算法的。</p>
<h2 id="常见排序算法分类"><a href="#常见排序算法分类" class="headerlink" title="常见排序算法分类"></a><strong>常见排序算法分类</strong></h2><p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。</p>
<p>常见排序算法一般分为以下几种：<br>（1）非线性时间比较类排序：交换类排序（快速排序和冒泡排序）、插入类排序（简单插入排序和希尔排序）、选择类排序（简单选择排序和堆排序）、归并排序（二路归并排序和多路归并排序）；<br>（2）线性时间非比较类排序：计数排序、基数排序和桶排序。</p>
<p>总结：<br>（1）在比较类排序中，归并排序号称最快，其次是快速排序和堆排序，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。<br>（2）线性时间非比较类排序一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要均匀。线性时间非比较类排序的典型特点是以空间换时间。</p>
<p>　有一点我们很容易忽略的是排序算法的稳定性(腾讯校招2016笔试题曾考过)。<br>　　排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。<br>　　对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。<br>　　其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p>
<h1 id="算法描述与实现"><a href="#算法描述与实现" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h1><h2 id="一，交换类排序"><a href="#一，交换类排序" class="headerlink" title="一，交换类排序"></a>一，交换类排序</h2><p>交换排序的基本方法是：两两比较待排序记录的排序码，交换不满足顺序要求的偶对，直到全部满足位置。常见的冒泡排序和快速排序就属于交换类排序。</p>
<p><strong>1，冒泡排序</strong><br>　冒泡排序是一种极其简单的排序算法，它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。<br>　　冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次。<br>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值： n*(n-1)/2。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)         <span class="comment">// 每次最大元素就像气泡一样"浮"到数组的最后</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++) <span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])            <span class="comment">// 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span></div><div class="line">            &#123;</div><div class="line">                Swap(A, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;    <span class="comment">// 从小到大冒泡排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    BubbleSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"冒泡排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2，鸡尾酒排序</strong></p>
<p>　　鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。<br>　　鸡尾酒排序的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;                            <span class="comment">// 初始化边界</span></div><div class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (left &lt; right)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)   <span class="comment">// 前半轮,将最大元素放到后面</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                Swap(A, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right--;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--)   <span class="comment">// 后半轮,将最小元素放到前面</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</div><div class="line">            &#123;</div><div class="line">                Swap(A, i - <span class="number">1</span>, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;   <span class="comment">// 从小到大定向冒泡排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    CocktailSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"鸡尾酒排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3，快速排序</strong><br>　　快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>　　快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：<br>从序列中挑出一个元素，作为”基准”(pivot).<br>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。<br>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。<br>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为<br>n<em>log2n。<br>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：n</em>(n-1)/2。<br><strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong><br>　　快速排序的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 --------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       </span></div><div class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">// 划分函数</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = A[right];               <span class="comment">// 这里每次都选择最后一个元素作为基准</span></div><div class="line">    <span class="keyword">int</span> tail = left - <span class="number">1</span>;                <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)  <span class="comment">// 遍历基准以外的其他元素</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (A[i] &lt;= pivot)              <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></div><div class="line">        &#123;</div><div class="line">            Swap(A, ++tail, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Swap(A, tail + <span class="number">1</span>, right);           <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></div><div class="line">                                        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></div><div class="line">    <span class="keyword">return</span> tail + <span class="number">1</span>;                    <span class="comment">// 返回基准的索引</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> pivot_index = Partition(A, left, right); <span class="comment">// 基准的索引</span></div><div class="line">    QuickSort(A, left, pivot_index - <span class="number">1</span>);</div><div class="line">    QuickSort(A, pivot_index + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;; <span class="comment">// 从小到大快速排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"快速排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二，插入类排序"><a href="#二，插入类排序" class="headerlink" title="二，插入类排序"></a>二，插入类排序</h2><p><strong>1，直接插入排序</strong><br>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。　对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。<br>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>　　具体算法描述如下：
　　</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li><p>重复步骤2~5</p>
<p>最好情况：当待排序记录已经有序，这时需要比较的次数是n-1；<br>最坏情况：如果待排序记录为逆序，则最多的比较次数为n*(n-1)/2;<br>插入排序的代码如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></div><div class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></div><div class="line">        &#123;</div><div class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;<span class="comment">// 从小到大插入排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    InsertionSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"插入排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>
<p><strong>2,二分插入排序</strong><br>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></div><div class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></div><div class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></div><div class="line">        &#123;</div><div class="line">            A[j + <span class="number">1</span>] = A[j];</div><div class="line">        &#125;</div><div class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大二分插入排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    InsertionSortDichotomy(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"二分插入排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<p><strong>3，Shell排序</strong></p>
<p>　　希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。<br>　　Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按d(i−1)分组排序，文件接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。<br>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。<br>　　希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li><p>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p>
<p>　　希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>　　假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>　　<strong>希尔排序是不稳定的排序算法</strong>，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。<br>　　Shell排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值比较合理，Shell排序算法的时间复杂度约为n^1.3。<br>　　对于增量的选择，Shell 最初建议增量选择为n/2，并且对增量取半直到 1；D. Knuth教授建议d(i+1)=[d(i-1)/3]序列。<br>　　希尔排序的代码如下：
　　</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (h &lt;= n)                          <span class="comment">// 生成初始增量</span></div><div class="line">    &#123;</div><div class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> j = i - h;</div><div class="line">            <span class="keyword">int</span> get = A[i];</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</div><div class="line">            &#123;</div><div class="line">                A[j + h] = A[j];</div><div class="line">                j = j - h;</div><div class="line">            &#125;</div><div class="line">            A[j + h] = get;</div><div class="line">        &#125;</div><div class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大希尔排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    ShellSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"希尔排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三，选择类排序"><a href="#三，选择类排序" class="headerlink" title="三，选择类排序"></a>三，选择类排序</h2><p>选择类排序的基本方法是：每步从待排序记录中选出排序码最小的记录，顺序放在已排序的记录序列的后面，知道全部排完。<br><strong>1，简单选择排序</strong><br>　　选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。<br>　　因简单选择排序也是常见排序算法中性能最差的排序算法。简单选择排序的比较次数与文件的初始状态没有关系，在第i趟排序中选出最小排序码的记录，需要做n-i次比较，因此总的比较次数是n<em>(n-1)/2。<br>　　<em>*选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</em></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></div><div class="line">            &#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (min != i)</div><div class="line">        &#123;</div><div class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span> &#125;; <span class="comment">// 从小到大选择排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    SelectionSort(A, n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"选择排序结果："</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2，堆排序</strong><br>　　鉴于。。我们都不怎么熟悉堆，先来讨论一下堆：<br>　<br>　　<strong>关于堆：</strong><br>　　（1）性质：完全二叉树或者是近似完全二叉树；<br>　　（2）分类：大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值；<br>　　（3）左右孩子：没有大小的顺序。<br>　　（4）堆的存储 ：一般都用数组来存储堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为 2\∗i+1和 2\∗i+2。<br>　　<strong>（5）堆的操作</strong> </p>
<p>　　<strong><1>插入：</1></strong> 将一个新元素插入到表尾，即数组末尾时，如果新构成的二叉树不满足堆的性质，需要重新排列元素。<br>　　每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中，这就类似于直接插入排序中将一个数据并入到有序区间中，这是节点“上浮”调整。不难写出插入一个新数据时堆的调整代码：
　　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新加入i结点,其父结点为(i-1)/2</span></div><div class="line"><span class="comment">//参数：a：数组，i：新插入元素在数组中的下标  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">minHeapFixUp</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> j, temp;  </div><div class="line">    temp = a[i];  </div><div class="line">    j = (i<span class="number">-1</span>)/<span class="number">2</span>;      <span class="comment">//父结点  </span></div><div class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span> (a[j] &lt;= temp)<span class="comment">//如果父节点不大于新插入的元素，停止寻找  </span></div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        a[i]=a[j];     <span class="comment">//把较大的子结点往下移动,替换它的子结点  </span></div><div class="line">        i = j;  </div><div class="line">        j = (i<span class="number">-1</span>)/<span class="number">2</span>;  </div><div class="line">    &#125;  </div><div class="line">    a[i] = temp;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，插入数据到最小堆时：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在最小堆中加入新的数据data  </span></div><div class="line"><span class="comment">//a：数组，index：插入的下标，</span></div><div class="line"><span class="keyword">void</span> minHeapAddNumber(<span class="keyword">int</span> a[], <span class="keyword">int</span> <span class="keyword">index</span>, <span class="keyword">int</span> data)  </div><div class="line">&#123;  </div><div class="line">    a[<span class="keyword">index</span>] = data;  </div><div class="line">    minHeapFixUp(a, <span class="keyword">index</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong><2>删除：</2></strong><br>　　堆排序中，删除一个元素总是发生在堆顶，因为堆顶的元素是最小的（小顶堆中）。表中最后一个元素用来填补空缺位置，结果树被更新以满足堆条件。</p>
<p>　　按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将数组最后一个数据与根结点，然后再从根结点开始进行一次从上向下的调整。<br>　　调整时先在左右儿子结点中找最小的，如果父结点不大于这个最小的子结点说明不需要调整了，反之将最小的子节点换到父结点的位置。此时父节点实际上并不需要换到最小子节点的位置，因为这不是父节点的最终位置。但逻辑上父节点替换了最小的子节点，然后再考虑父节点对后面的结点的影响。相当于从根结点将一个数据的“下沉”过程。下面给出代码：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a为数组，从index节点开始调整,len为节点总数 从0开始计算index节点的子节点为 2*index+1, 2*index+2,len/2-1为最后一个非叶子节点  </span></div><div class="line"><span class="keyword">void</span> minHeapFixDown(<span class="keyword">int</span> a[],<span class="keyword">int</span> len,<span class="keyword">int</span> <span class="keyword">index</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">index</span>&gt;(len/<span class="number">2</span><span class="number">-1</span>))<span class="comment">//index为叶子节点不用调整</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> tmp=a[<span class="keyword">index</span>];</div><div class="line">    <span class="keyword">int</span> lastIndex=<span class="keyword">index</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">index</span>&lt;=(len/<span class="number">2</span><span class="number">-1</span>))&#123; <span class="comment">//当下沉到叶子节点时，就不用调整了</span></div><div class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>]&lt;tmp) <span class="comment">//如果左子节点大于该节点</span></div><div class="line">            lastIndex = <span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>;</div><div class="line">        <span class="comment">//如果存在右子节点且大于左子节点和该节点</span></div><div class="line">        <span class="keyword">if</span>(<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>&lt;len &amp;&amp; a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>]&lt;a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">1</span>]&amp;&amp; a[<span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>]&lt;tmp)</div><div class="line">            lastIndex = <span class="number">2</span>*<span class="keyword">index</span>+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(lastIndex!=<span class="keyword">index</span>)&#123;  <span class="comment">//如果左右子节点有一个小于该节点则设置该节点的下沉位置</span></div><div class="line">            a[<span class="keyword">index</span>]=a[lastIndex];</div><div class="line">            <span class="keyword">index</span>=lastIndex;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">//否则该节点不用下沉调整</span></div><div class="line">    &#125;</div><div class="line">    a[lastIndex]=tmp;<span class="comment">//将该节点放到最后的位置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong><3>建堆：</3></strong><br>　　有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！
　　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立最小堆</span></div><div class="line"><span class="comment">//a:数组，n：数组长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeMinHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">        minHeapFixDown(a, i, n);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。<br>　　我们可以很容易的定义堆排序的过程：
　　</p>
<ul>
<li>由输入的无序数组构造一个最大堆，作为初始的无序区</li>
<li>把堆顶元素（最大值）和堆尾元素互换</li>
<li>把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整</li>
<li><p>重复步骤2，直到堆的尺寸为1</p>
<p><strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></div><div class="line"><span class="comment">// 数据结构 ---------- 数组</span></div><div class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></div><div class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></div><div class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> Swap(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Heapify(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> <span class="built_in">size</span>)  <span class="comment">// 从A[i]向下进行堆调整</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></div><div class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></div><div class="line">    <span class="built_in">if</span> (left_child &lt; <span class="built_in">size</span> &amp;&amp; A[left_child] &gt; A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span> = left_child;</div><div class="line">    <span class="built_in">if</span> (right_child &lt; <span class="built_in">size</span> &amp;&amp; A[right_child] &gt; A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span> = right_child;</div><div class="line">    <span class="built_in">if</span> (<span class="built_in">max</span> != i)</div><div class="line">    &#123;</div><div class="line">        Swap(A, i, <span class="built_in">max</span>);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></div><div class="line">        Heapify(A, <span class="built_in">max</span>, <span class="built_in">size</span>);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> BuildHeap(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)           <span class="comment">// 建堆，时间复杂度O(n)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = n;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></div><div class="line">        Heapify(A, i, heap_size);</div><div class="line">    <span class="built_in">return</span> heap_size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></div><div class="line">    <span class="built_in">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></div><div class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></div><div class="line">        Swap(A, <span class="number">0</span>, --heap_size);</div><div class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大堆排序</span></div><div class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    HeapSort(A, n);</div><div class="line">    printf(<span class="string">"堆排序结果："</span>);</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, A[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong>堆排序的性能分析</strong><br>由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次堆调整操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。两次次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。<br>最坏情况：如果待排序数组是有序的，仍然需要O(N * logN)复杂度的比较操作，只是少了移动的操作；<br>最好情况：如果待排序数组是逆序的，不仅需要O(N * logN)复杂度的比较操作，而且需要O(N * logN)复杂度的交换操作。总的时间复杂度还是O(N * logN)。<br>因此，堆排序和快速排序在效率上是差不多的，但是堆排序一般优于快速排序的重要一点是，数据的初始分布情况对堆排序的效率没有大的影响。</p>
<h2 id="四，归并排序"><a href="#四，归并排序" class="headerlink" title="四，归并排序"></a>四，归并排序</h2><p>　　归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。<br>　　归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。<br>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：
　　</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;limits.h&gt;</div><div class="line"></div><div class="line">// 分类 -------------- 内部比较排序</div><div class="line">// 数据结构 ---------- 数组</div><div class="line">// 最差时间复杂度 ---- O(nlogn)</div><div class="line">// 最优时间复杂度 ---- O(nlogn)</div><div class="line">// 平均时间复杂度 ---- O(nlogn)</div><div class="line">// 所需辅助空间 ------ O(<span class="built_in">n</span>)</div><div class="line">// 稳定性 ------------ 稳定</div><div class="line"></div><div class="line"></div><div class="line">void Merge(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)// 合并两个已排好序的数组A[left...mid]和A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = <span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span> *temp = new <span class="built_in">int</span>[<span class="built_in">len</span>];       // 辅助空间O(<span class="built_in">n</span>)</div><div class="line">    <span class="built_in">int</span> <span class="built_in">index</span> = <span class="number">0</span>;</div><div class="line">    <span class="built_in">int</span> i = <span class="built_in">left</span>;                   // 前一数组的起始元素</div><div class="line">    <span class="built_in">int</span> j = <span class="built_in">mid</span> + <span class="number">1</span>;                // 后一数组的起始元素</div><div class="line">    while (i &lt;= <span class="built_in">mid</span> &amp;&amp; j &lt;= <span class="built_in">right</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[i] &lt;= A[j] ? A[i++] <span class="symbol">:</span> A[j++];  // 带等号保证归并排序的稳定性</div><div class="line">    &#125;</div><div class="line">    while (i &lt;= <span class="built_in">mid</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[i++];</div><div class="line">    &#125;</div><div class="line">    while (j &lt;= <span class="built_in">right</span>)</div><div class="line">    &#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[j++];</div><div class="line">    &#125;</div><div class="line">    for (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>; k++)</div><div class="line">    &#123;</div><div class="line">        A[<span class="built_in">left</span>++] = temp[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void MergeSortRecursion(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)    // 递归实现的归并排序(自顶向下)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">if</span> (<span class="built_in">left</span> == <span class="built_in">right</span>)    // 当待排序的序列长度为<span class="number">1</span>时，递归开始回溯，进行merge操作</div><div class="line">        return;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</div><div class="line">    MergeSortRecursion(A, <span class="built_in">left</span>, <span class="built_in">mid</span>);</div><div class="line">    MergeSortRecursion(A, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</div><div class="line">    Merge(A, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void MergeSortIteration(<span class="built_in">int</span> A[], <span class="built_in">int</span> <span class="built_in">len</span>)    // 非递归(迭代)实现的归并排序(自底向上)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">len</span>; i *= <span class="number">2</span>)        // 子数组的大小i初始为<span class="number">1</span>，每轮翻倍</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">left</span> = <span class="number">0</span>;</div><div class="line">        while (<span class="built_in">left</span> + i &lt; <span class="built_in">len</span>)              // 后一个子数组存在(需要归并)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">mid</span> = <span class="built_in">left</span> + i - <span class="number">1</span>;</div><div class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span> + i &lt; <span class="built_in">len</span> ? <span class="built_in">mid</span> + i <span class="symbol">:</span> <span class="built_in">len</span> - <span class="number">1</span>;// 后一个子数组大小可能不够</div><div class="line">            Merge(A, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</div><div class="line">            <span class="built_in">left</span> = <span class="built_in">right</span> + <span class="number">1</span>;               // 前一个子数组索引向后移动</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> <span class="symbol">A1</span>[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;      // 从小到大归并排序</div><div class="line">    <span class="built_in">int</span> <span class="symbol">A2</span>[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="built_in">int</span> <span class="symbol">n1</span> = sizeof(<span class="symbol">A1</span>) / sizeof(<span class="built_in">int</span>);</div><div class="line">    <span class="built_in">int</span> <span class="symbol">n2</span> = sizeof(<span class="symbol">A2</span>) / sizeof(<span class="built_in">int</span>);</div><div class="line">    MergeSortRecursion(<span class="symbol">A1</span>, <span class="number">0</span>, <span class="symbol">n1</span> - <span class="number">1</span>);          // 递归实现</div><div class="line">    MergeSortIteration(<span class="symbol">A2</span>, <span class="symbol">n2</span>);                 // 非递归实现</div><div class="line">    printf(<span class="string">"递归实现的归并排序结果："</span>);</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="symbol">n1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, <span class="symbol">A1</span>[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"非递归实现的归并排序结果："</span>);</div><div class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="symbol">n2</span>; i++)</div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"%d "</span>, <span class="symbol">A2</span>[i]);</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="五，非比较排序"><a href="#五，非比较排序" class="headerlink" title="五，非比较排序"></a>五，非比较排序</h2><p><strong>1.计数排序</strong><br>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出，它的优势在于在对于较小范围内的整数排序。它的复杂度为Ο(n+k)（其中k是待排序数的范围），快于任何比较排序算法，缺点就是非常消耗空间。很明显，如果而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序，比如堆排序和归并排序和快速排序。<br>算法原理：<br>基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，在代码中作适当的修改即可。<br>算法步骤：<br>（1）找出待排序的数组中最大的元素；<br>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<br>时间复杂度：Ο(n+k)。<br>空间复杂度：Ο(k)。<br>要求：待排序数中最大数值不能太大。<br>稳定性：稳定。<br>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 20    <span class="comment">//待排序数的最大个数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX    100   <span class="comment">//待排序数的最大值</span></span></div><div class="line"><span class="keyword">int</span> sorted_arr[MAXNUM]=&#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//计算排序</span></div><div class="line"><span class="comment">//arr:待排序数组，sorted_arr：排好序的数组，n：待排序数组长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> *sorted_arr, <span class="keyword">int</span> n)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> i;   </div><div class="line">    <span class="keyword">int</span> *count_arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX+<span class="number">1</span>));  </div><div class="line"></div><div class="line">    <span class="comment">//初始化计数数组   </span></div><div class="line">    <span class="built_in">memset</span>(count_arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX+<span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="comment">//统计i的次数   </span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n;i++)  </div><div class="line">        count_arr[arr[i]]++;  </div><div class="line">    <span class="comment">//对所有的计数累加，作用是统计arr数组值和小于小于arr数组值出现的个数</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=MAX; i++)  </div><div class="line">        count_arr[i] += count_arr[i<span class="number">-1</span>];   </div><div class="line">    <span class="comment">//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到新的数组中   </span></div><div class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//count_arr[arr[i]]表示arr数组中包括arr[i]和小于arr[i]的总数</span></div><div class="line">        sorted_arr[count_arr[arr[i]]<span class="number">-1</span>] = arr[i];  </div><div class="line"></div><div class="line">        <span class="comment">//如果arr数组中有相同的数，arr[i]的下标减一</span></div><div class="line">        count_arr[arr[i]]--;    </div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(count_arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：计数排序是典型的以空间换时间的排序算法，对待排序的数据有严格的要求，比如待排序的数值中不能包含负数，最大值也有限制，请谨慎使用。<br><strong>2.基数排序</strong><br>基数排序属于“分配式排序”（distribution sort），是非比较类线性时间排序的一种，又称“桶子法”（bucket sort）。顾名思义，它是透过键值的部分信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。<br>基数排序（以整形为例），将整形10进制按每位拆分，然后从低位到高位依次比较各个位。主要分为两个过程：<br>　　(1)分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中（比如６4，个位为４，则放入４号桶中）；<br>　　(2)收集，再将放置在0~9号桶中的数据按顺序放到数组中；<br>　　重复(1)(2)过程，从个位到最高位（比如32位无符号整形最大数4294967296，最高位为第10位）。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<br>　　平均时间复杂度：O(dn)(d即表示整形的最高位数)。<br>　　空间复杂度：O(10n) （10表示0~9，用于存储临时的序列） 。<br>　　稳定性：稳定。<br>　<br>（1）MSD法实现<br>最高位优先法通常是一个递归的过程：</p>
<p><1>先根据最高位关键码K1排序，得到若干对象组，对象组中每个对象都有相同关键码K1。 </1></p>
<p><2>再分别对每组中对象根据关键码K2进行排序，按K2值的不同，再分成若干个更小的子组，每个子组中的对象具有相同的K1和K2值。</2></p>
<p><3>依此重复，直到对关键码Kd完成排序为止。</3></p>
<p><4> 最后，把所有子组中的对象依次连接起来，就得到一个有序的对象序列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdigit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;     <span class="comment">//因为待排数据最大数据也只是两位数，所以在此只需要到十位就满足</span></div><div class="line">    <span class="keyword">return</span> ((x / a[d]) % <span class="number">10</span>);    <span class="comment">//确定桶号</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintArr</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ar[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">msdradix_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;     </div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> radix = <span class="number">10</span>;   </div><div class="line">    <span class="keyword">int</span> count[radix], i, j; </div><div class="line">    <span class="comment">//置空</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; radix; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[i] = <span class="number">0</span>;   </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//分配桶存储空间</span></div><div class="line">    <span class="keyword">int</span> *bucket = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((end-begin+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    </div><div class="line">    <span class="comment">//统计各桶需要装的元素的个数  </span></div><div class="line">    <span class="keyword">for</span>(i = begin;i &lt;= end; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[getdigit(arr[i], d)]++;   </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求出桶的边界索引，count[i]值为第i个桶的右边界索引+1</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; ++i)   </div><div class="line">    &#123;</div><div class="line">        count[i] = count[i] + count[i<span class="number">-1</span>];    </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里要从右向左扫描，保证排序稳定性 </span></div><div class="line">    <span class="keyword">for</span>(i = end;i &gt;= begin; --i)          </div><div class="line">    &#123;    </div><div class="line">        j = getdigit(arr[i], d);      <span class="comment">//求出关键码的第d位的数字， 例如：576的第3位是5   </span></div><div class="line">        bucket[count[j]<span class="number">-1</span>] = arr[i];   <span class="comment">//放入对应的桶中，count[j]-1是第j个桶的右边界索引   </span></div><div class="line">        --count[j];                    <span class="comment">//第j个桶放下一个元素的位置(右边界索引+1)   </span></div><div class="line">    &#125;   </div><div class="line">    <span class="comment">//注意：此时count[i]为第i个桶左边界    </span></div><div class="line">    <span class="comment">//从各个桶中收集数据  </span></div><div class="line">    <span class="keyword">for</span>(i = begin, j = <span class="number">0</span>;i &lt;= end; ++i, ++j)  </div><div class="line">    &#123;</div><div class="line">        arr[i] = bucket[j]; </div><div class="line">    &#125;       </div><div class="line">    <span class="comment">//释放存储空间</span></div><div class="line">    <span class="built_in">free</span>(bucket);   </div><div class="line">    <span class="comment">//对各桶中数据进行再排序</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; radix; i++)  </div><div class="line">    &#123;   </div><div class="line">        <span class="keyword">int</span> p1 = begin + count[i];         <span class="comment">//第i个桶的左边界   </span></div><div class="line">        <span class="keyword">int</span> p2 = begin + count[i+<span class="number">1</span>]<span class="number">-1</span>;     <span class="comment">//第i个桶的右边界   </span></div><div class="line">        <span class="keyword">if</span>(p1 &lt; p2 &amp;&amp; d &gt; <span class="number">1</span>)  </div><div class="line">        &#123;</div><div class="line">            msdradix_sort(arr, p1, p2, d<span class="number">-1</span>);  <span class="comment">//对第i个桶递归调用，进行基数排序，数位降 1    </span></div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>  ar[] = &#123;<span class="number">12</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">47</span>, <span class="number">89</span>&#125;;</div><div class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序前数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(ar, len);</div><div class="line">    msdradix_sort(ar, <span class="number">0</span>, len<span class="number">-1</span>, <span class="number">2</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后结果如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(ar, len);</div><div class="line">&#125; </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">排序前数据如下：</span></div><div class="line"><span class="comment">12 14 54 5 6 3 9 8 47 89</span></div><div class="line"><span class="comment">排序后结果如下：</span></div><div class="line"><span class="comment">3 5 6 8 9 12 14 47 54 89</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></4></p>
<p>（2）LSD法实现<br>最低位优先法首先依据最低位关键码Kd对所有对象进行一趟排序，<br>再依据次低位关键码Kd-1对上一趟排序的结果再排序，<br>依次重复，直到依据关键码K1最后一趟排序完成，就可以得到一个有序的序列。<br>使用这种排序方法对每一个关键码进行排序时，不需要再分组，而是整个对象组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>   MAXSIZE   10000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdigit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>&#125;;   <span class="comment">//最大三位数，所以这里只要百位就满足了。</span></div><div class="line">    <span class="keyword">return</span> (x/a[d]) % <span class="number">10</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PrintArr</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ar[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsdradix_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> d)</span>  </span></div><div class="line"><span class="function"></span>&#123;    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> radix = <span class="number">10</span>;   </div><div class="line">    <span class="keyword">int</span> count[radix], i, j; </div><div class="line"></div><div class="line">    <span class="keyword">int</span> *bucket = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((end-begin+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">//所有桶的空间开辟   </span></div><div class="line">   </div><div class="line">    <span class="comment">//按照分配标准依次进行排序过程</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; ++k)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//置空</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; radix; i++)  </div><div class="line">        &#123;</div><div class="line">            count[i] = <span class="number">0</span>;        </div><div class="line">        &#125;               </div><div class="line">        <span class="comment">//统计各个桶中所盛数据个数</span></div><div class="line">        <span class="keyword">for</span>(i = begin; i &lt;= end; i++) </div><div class="line">        &#123;</div><div class="line">           count[getdigit(arr[i], k)]++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//count[i]表示第i个桶的右边界索引</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; radix; i++) </div><div class="line">        &#123;</div><div class="line">            count[i] = count[i] + count[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把数据依次装入桶(注意装入时候的分配技巧)</span></div><div class="line">        <span class="keyword">for</span>(i = end;i &gt;= begin; --i)        <span class="comment">//这里要从右向左扫描，保证排序稳定性   </span></div><div class="line">        &#123;    </div><div class="line">            j = getdigit(arr[i], k);        <span class="comment">//求出关键码的第k位的数字， 例如：576的第3位是5   </span></div><div class="line">            bucket[count[j]<span class="number">-1</span>] = arr[i]; <span class="comment">//放入对应的桶中，count[j]-1是第j个桶的右边界索引 </span></div><div class="line">            --count[j];               <span class="comment">//对应桶的装入数据索引减一  </span></div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">//注意：此时count[i]为第i个桶左边界  </span></div><div class="line">        </div><div class="line">        <span class="comment">//从各个桶中收集数据</span></div><div class="line">        <span class="keyword">for</span>(i = begin,j = <span class="number">0</span>; i &lt;= end; ++i, ++j)  </div><div class="line">        &#123;</div><div class="line">            arr[i] = bucket[j];    </div><div class="line">        &#125;        </div><div class="line">    &#125;     </div><div class="line">    <span class="built_in">free</span>(bucket);   </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>  br[<span class="number">10</span>] = &#123;<span class="number">20</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">589</span>, <span class="number">998</span>, <span class="number">965</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>&#125;;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"原数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(br,<span class="number">10</span>);</div><div class="line">    lsdradix_sort(br, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后数据如下："</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PrintArr(br, <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">原数据如下：</span></div><div class="line"><span class="comment">20 80 90 589 998 965 852 123 456 789</span></div><div class="line"><span class="comment">排序后数据如下：</span></div><div class="line"><span class="comment">20 80 90 123 456 589 789 852 965 998</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p><strong>3.桶排序</strong><br>桶排序也是分配排序的一种，但其是基于比较排序的，这也是与基数排序最大的区别所在。<br>思想：桶排序算法想法类似于散列表。首先要假设待排序的元素输入符合某种均匀分布，例如数据均匀分布在[ 0,1）区间上，则可将此区间划分为10个小区间，称为桶，对散布到同一个桶中的元素再排序。<br>要求：待排序数长度一致。<br>排序过程：<br>（1）设置一个定量的数组当作空桶子；<br>（2）寻访序列，并且把记录一个一个放到对应的桶子去；<br>（3）对每个不是空的桶子进行排序。<br>（4）从不是空的桶子里把项目再放回原来的序列中。<br>时间复杂度：<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，对于N个待排数据，M个桶，平均每个桶[N/M]个数据，则桶内排序的时间复杂度为O(N*log2(N/M))。<br>因此，平均时间复杂度为线性的O(N+C)，C为桶内排序所花费的时间。当每个桶只有一个数，则最好的时间复杂度为：O(N)。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line"> &#123; </div><div class="line">     int keyNum;<span class="comment">//桶中数的数量</span></div><div class="line">     int key;   <span class="comment">//存储的元素</span></div><div class="line">     struct node * next;  </div><div class="line"> &#125;KeyNode;    </div><div class="line"></div><div class="line"> <span class="comment">//keys待排序数组，size数组长度，bucket_size桶的数量</span></div><div class="line"> void inc_sort(int keys[],int size,int bucket_size)</div><div class="line"> &#123; </div><div class="line">     KeyNode* k=(KeyNode *)malloc(sizeof(KeyNode)); <span class="comment">//用于控制打印</span></div><div class="line">     int i,j,b;</div><div class="line">     KeyNode **bucket_table=(KeyNode **)malloc(bucket_size*sizeof(KeyNode *)); </div><div class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bucket_size;i++)</div><div class="line">     &#123;  </div><div class="line">         bucket_table[i]=(KeyNode *)malloc(sizeof(KeyNode)); </div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>keyNum=<span class="number">0</span>;<span class="comment">//记录当前桶中是否有数据</span></div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>key=<span class="number">0</span>;   <span class="comment">//记录当前桶中的数据  </span></div><div class="line">         <span class="function"><span class="title">bucket_table</span>[i]-&gt;</span>next=NULL; </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">     <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)</div><div class="line">     &#123;   </div><div class="line">         int index;</div><div class="line">         KeyNode *p;</div><div class="line">         KeyNode *node=(KeyNode *)malloc(sizeof(KeyNode));   </div><div class="line">         <span class="function"><span class="title">node</span>-&gt;</span>key=keys[j];  </div><div class="line">         <span class="function"><span class="title">node</span>-&gt;</span>next=NULL;  </div><div class="line"></div><div class="line">         index=keys[j]/<span class="number">10</span>;        <span class="comment">//映射函数计算桶号  </span></div><div class="line">         p=bucket_table[index];   <span class="comment">//初始化P成为桶中数据链表的头指针  </span></div><div class="line">         <span class="function"><span class="title">if</span>(p-&gt;</span>keyNum==<span class="number">0</span>)<span class="comment">//该桶中还没有数据 </span></div><div class="line">         &#123;    </div><div class="line">             <span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>next=node;    </div><div class="line">             (<span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>keyNum)++;  <span class="comment">//桶的头结点记录桶内元素各数，此处加一</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span><span class="comment">//该桶中已有数据 </span></div><div class="line">         &#123;   </div><div class="line">             <span class="comment">//链表结构的插入排序 </span></div><div class="line">             <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">next</span>!=NULL&amp;&amp;p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">key</span>&lt;=node-&gt;</span>key)   </div><div class="line">                 <span class="function"><span class="title">p</span>=p-&gt;</span>next;    </div><div class="line">             <span class="function"><span class="title">node</span>-&gt;</span><span class="function"><span class="title">next</span>=p-&gt;</span>next;     </div><div class="line">             <span class="function"><span class="title">p</span>-&gt;</span>next=node;      </div><div class="line">             (<span class="function"><span class="title">bucket_table</span>[index]-&gt;</span>keyNum)++;   </div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//打印结果</span></div><div class="line">     <span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;bucket_size;b++)   </div><div class="line">         <span class="comment">//判断条件是跳过桶的头结点，桶的下个节点为元素节点不为空</span></div><div class="line">         <span class="function"><span class="title">for</span>(k=bucket_table[b];k-&gt;</span><span class="function"><span class="title">next</span>!=NULL;k=k-&gt;</span>next)  </div><div class="line">         &#123;</div><div class="line">             <span class="function"><span class="title">printf</span>("%d ",k-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>key);</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>开头那道题的题解。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="keyword">int</span> b[maxn];</div><div class="line"><span class="keyword">int</span> m, n, k;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (l &lt;= r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (b[mid] &lt;= x)</div><div class="line">            l = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            r = mid - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ll ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">    &#123;</div><div class="line">            <span class="keyword">if</span> (!a[i])<span class="comment">// 如果a[i] 是0的话 那么这一排m必取</span></div><div class="line">            &#123;</div><div class="line">                ans += n;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> cnt = x / a[i];<span class="comment">//a[i]* cnt=x; 求最大的cnt 其他比</span></div><div class="line">            <span class="comment">//cnt小的 都要加起来</span></div><div class="line">            ans += getsum(cnt);<span class="comment">//在b里找 比cnt小的</span></div><div class="line">    &#125;</div><div class="line">     <span class="keyword">return</span> ans &gt;= k;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;m,&amp;n,&amp;k);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</div><div class="line">    sort(a,a+m);</div><div class="line">    sort(b,b+n);</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> r = a[m<span class="number">-1</span>]*b[n<span class="number">-1</span>];</div><div class="line">    <span class="keyword">while</span>(l&lt;=r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</div><div class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在C++的STL中封装了一个叫优先队列的东西，它的实现原理和堆非常类似，可以直接使用。<br><strong>优先队列</strong>：<br>顾名思义，首先它是一个队列，但是它强调了“优先”二字，所以，已经不能算是一般意义上的队列了，它的“优先”意指取队首元素时，有一定的选择性，即根据元素的属性选择某一项值最优的出队~<br>百度百科上这样描述的：<br>　　优先级队列 是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素<br>　　优先队列的类定义　　<br>　　优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priorityq u e u e)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.<br>其声明格式为：priority_queue <int> ans;//声明一个名为ans的整形的优先队列<br>基本操作有：<br>empty( )  //判断一个队列是否为空<br>pop( )  //删除队顶元素<br>push( )  //加入一个元素<br>size( )  //返回优先队列中拥有的元素个数<br>top( )  //返回优先队列的队顶元素</int></p>
<p>优先队列的时间复杂度为O（logn），n为队列中元素的个数，其存取都需要时间。</p>
<p>在默认的优先队列中，优先级最高的先出队。默认的int类型的优先队列中先出队的为队列中较大的数。</p>
<p>然而更多的情况下，我们是希望可以自定义其优先级的，下面介绍几种常用的定义优先级的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*优先队列的基本使用    2010/7/24    dooder*/</span>  </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="comment">//定义结构，使用运算符重载,自定义优先级1  </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span>  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span>  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> a&lt;b;<span class="comment">//最大值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="comment">//定义结构，使用运算符重载,自定义优先级2  </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number1</span>&#123;</span>  </div><div class="line">    <span class="keyword">int</span> x;  </div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;  </div><div class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number2</span>&#123;</span>  </div><div class="line">    <span class="keyword">int</span> x;  </div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number2 &amp;a) <span class="keyword">const</span> &#123;  </div><div class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//最大值优先  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">number1 num1[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">number2 num2[]=&#123;<span class="number">14</span>,<span class="number">10</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">83</span>,<span class="number">22</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">3</span>,<span class="number">47</span>,<span class="number">72</span>,<span class="number">0</span>&#125;;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;   priority_queue&lt;<span class="keyword">int</span>&gt;que;<span class="comment">//采用默认优先级构造队列  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先  </span></div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;que2;<span class="comment">//最大值优先  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，  </span></div><div class="line">                                                      <span class="comment">//这是右移运算符，所以这里用空格号隔开  </span></div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;que4;<span class="comment">////最大值优先  </span></div><div class="line">  </div><div class="line">    priority_queue&lt;number1&gt;que5;  </div><div class="line">    priority_queue&lt;number2&gt;que6;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;a[i];i++)&#123;  </div><div class="line">        que.push(a[i]);  </div><div class="line">        que1.push(a[i]);  </div><div class="line">        que2.push(a[i]);  </div><div class="line">        que3.push(a[i]);  </div><div class="line">        que4.push(a[i]);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;num1[i].x;i++)  </div><div class="line">        que5.push(num1[i]);  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;num2[i].x;i++)  </div><div class="line">        que6.push(num2[i]);  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用默认优先关系:\n(priority_queue&lt;int&gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 0:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que.top());  </div><div class="line">        que.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用结构体自定义优先级方式一:\n(priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 1:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que1.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que1.top());  </div><div class="line">        que1.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 2:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que2.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que2.top());  </div><div class="line">        que2.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用头文件\"functional\"内定义优先级:\n(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;/less&lt;int&gt; &gt;que;)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 3:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que3.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que3.top());  </div><div class="line">        que3.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 4:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que4.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que4.top());  </div><div class="line">        que4.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用结构体自定义优先级方式二:\n(priority_queue&lt;number&gt;que)\n"</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 5:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que5.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que5.top());  </div><div class="line">        que5.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Queue 6:\n"</span>);  </div><div class="line">    <span class="keyword">while</span>(!que6.empty())&#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que6.top());  </div><div class="line">        que6.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment">运行结果 ： </span></div><div class="line"><span class="comment">采用默认优先关系: </span></div><div class="line"><span class="comment">(priority_queue&lt;int&gt;que;) </span></div><div class="line"><span class="comment">Queue 0: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用结构体自定义优先级方式一: </span></div><div class="line"><span class="comment">(priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;que;) </span></div><div class="line"><span class="comment">Queue 1: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 2: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用头文件"functional"内定义优先级: </span></div><div class="line"><span class="comment">(priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;/less&lt;int&gt; &gt;que;) </span></div><div class="line"><span class="comment">Queue 3: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 4: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">采用结构体自定义优先级方式二: </span></div><div class="line"><span class="comment">(priority_queue&lt;number&gt;que) </span></div><div class="line"><span class="comment">Queue 5: </span></div><div class="line"><span class="comment"> 7 10 14 22 36 47 56 72 83 91 </span></div><div class="line"><span class="comment">Queue 6: </span></div><div class="line"><span class="comment">83 72 56 47 36 22 14 10  7  3 </span></div><div class="line"><span class="comment">*/</span>  </div><div class="line">运行结果：</div><div class="line">采用默认优先关系:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>&gt;que;)</div><div class="line">Queue <span class="number">0</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用结构体自定义优先级方式一:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp&gt;que;)</div><div class="line">Queue <span class="number">1</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">2</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用头文件<span class="string">"functional"</span>内定义优先级:</div><div class="line">(priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;/less&lt;<span class="keyword">int</span>&gt; &gt;que;)</div><div class="line">Queue <span class="number">3</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">4</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div><div class="line">采用结构体自定义优先级方式二:</div><div class="line">(priority_queue&lt;number&gt;que)</div><div class="line">Queue <span class="number">5</span>:</div><div class="line"> <span class="number">7</span> <span class="number">10</span> <span class="number">14</span> <span class="number">22</span> <span class="number">36</span> <span class="number">47</span> <span class="number">56</span> <span class="number">72</span> <span class="number">83</span> <span class="number">91</span></div><div class="line">Queue <span class="number">6</span>:</div><div class="line"><span class="number">83</span> <span class="number">72</span> <span class="number">56</span> <span class="number">47</span> <span class="number">36</span> <span class="number">22</span> <span class="number">14</span> <span class="number">10</span>  <span class="number">7</span>  <span class="number">3</span></div></pre></td></tr></table></figure>
<p>引用：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/eniac12/p/5329396.html#s4" target="_blank" rel="external">https://www.cnblogs.com/eniac12/p/5329396.html#s4</a><br><a href="http://blog.csdn.net/k346k346/article/details/50791102" target="_blank" rel="external">http://blog.csdn.net/k346k346/article/details/50791102</a><br><a href="https://www.cnblogs.com/Braveliu/archive/2013/01/21/2870201.html" target="_blank" rel="external">https://www.cnblogs.com/Braveliu/archive/2013/01/21/2870201.html</a><br><a href="http://blog.csdn.net/qq_36553623/article/details/72809695" target="_blank" rel="external">http://blog.csdn.net/qq_36553623/article/details/72809695</a><br><a href="http://www.cnblogs.com/heqinghui/archive/2013/07/30/3225407.html" target="_blank" rel="external">http://www.cnblogs.com/heqinghui/archive/2013/07/30/3225407.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/15/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/undefined-title/" itemprop="url">818</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T17:13:56+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　其实我想做这件事好久了。。。</p>
<p>　　按你国考试的标准答案，诗人的流派是早已被定义的。比如某人的豪迈激越，某人的沉郁顿挫，不一而足。于是。。。</p>
<h2 id="苏轼"><a href="#苏轼" class="headerlink" title="苏轼"></a>苏轼</h2><p>　　先从被无数人认为字东坡的苏子瞻开始吧。</p>
<blockquote>
<p>　　苏轼是北宋中期的文坛领袖，在诗、词、散文、书、画等方面取得了很高的成就。其文纵横恣肆；其诗题材广阔，清新豪健，善用夸张比喻，独具风格，与黄庭坚并称“苏黄”；其词开豪放一派，与辛弃疾同是豪放派代表，并称“苏辛“；其散文著述宏富，豪放自如，与欧阳修并称“欧苏”，为“唐宋八大家”之一。——from baidu</p>
</blockquote>
<p>　　//其实对于稍有积累的人来说没有什么必要。<br>　　然而经历了乌台诗案和丧妻之后的苏先森也并不总是”也无风雨也无晴”的。<br>　　<br>　　<strong>江城子·乙卯正月二十日夜记梦</strong><br>　　十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。<br>　　夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p>
<p>　　<strong>蝶恋花·春景</strong><br>　　花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！<br>　　墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。 </p>
<p>　　<strong>水龙吟·次韵章质夫杨花词</strong><br>　　似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。<br>　　不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。 </p>
<p>　　<strong>西江月</strong><br>　　世事一场大梦，人生几度秋凉？夜来风叶已鸣廊。看取眉头鬓上。<br>　　酒贱常愁客少，月明多被云妨。中秋谁与共孤光。把盏凄然北望。 </p>
<p>　　<strong>海棠</strong><br>　　东风袅袅泛崇光，香雾空蒙月转廊。<br>　　只恐夜深花睡去，故烧高烛照红妆。 </p>
<p>　　<strong>春宵</strong><br>　　春宵一刻值千金，花有清香月有阴。<br>　　歌管楼台声细细，秋千院落夜沉沉。</p>
<p>　　<strong>浣溪沙</strong><br>　　元丰七年十二月二十四日，从泗州刘倩叔游南山<br>　　<br>　　细雨斜风作晓寒，淡烟疏柳媚晴滩。入淮清洛渐漫漫。<br>　　雪沫乳花浮午盏，蓼茸蒿笋试春盘。人间有味是清欢。</p>
<p>　　还有好多，比如著名的”一树梨花压海棠“，懒得复制粘贴了。</p>
<h2 id="陆游"><a href="#陆游" class="headerlink" title="陆游"></a>陆游</h2><blockquote>
<p>　　陆游生逢北宋灭亡之际，少年时即深受家庭爱国思想的熏陶。宋高宗时，参加礼部考试，因受秦桧排斥而仕途不畅。宋孝宗即位后，赐进士出身，历任福州宁德县主簿、敕令所删定官、隆兴府通判等职，因坚持抗金，屡遭主和派排斥。乾道七年（1171年），应四川宣抚使王炎之邀，投身军旅，任职于南郑幕府。次年，幕府解散，陆游奉诏入蜀，与范成大相知。宋光宗继位后，升为礼部郎中兼实录院检讨官，不久即因“嘲咏风月”罢官归居故里。嘉泰二年（1202年），宋宁宗诏陆游入京，主持编修孝宗、光宗《两朝实录》和《三朝史》，官至宝章阁待制。书成后，陆游长期蛰居山阴，嘉定二年（1210年）与世长辞，留绝笔《示儿》。<br>　　陆游一生笔耕不辍，诗词文俱有很高成就，其诗语言平易晓畅、章法整饬谨严，兼具李白的雄奇奔放与杜甫的沉郁悲凉，尤以饱含爱国热情对后世影响深远。陆游亦有史才，他的《南唐书》，“简核有法”，史评色彩鲜明，具有很高的史料价值。——from baidu</p>
</blockquote>
<p>　　与苏轼有类似遭遇的还有我们最多产的诗人一树梅花一放翁。之前提苏轼毕竟有点。。。一介酸腐文人怎能豪放？陆游倒是做过军中幕僚，我们且看他是怎么怀念和表妹的往事的：<br>　　<strong>钗头凤</strong><br>　　红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。<br>　　春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！<br>　　<br>　　<strong>沈园二首</strong><br>　　城上斜阳画角哀，沈园非复旧池台，<br>　　伤心桥下春波绿，曾是惊鸿照影来。<br>　　<br>　　梦断香消四十年，沈园柳老不吹绵。<br>　　此身行作稽山土，犹吊遗踪一泫然。</p>
<p>　　不怀念的也有：<br>　　<strong>临安春雨初霁</strong><br>　　世味年来薄似纱，谁令骑马客京华。<br>　　小楼一夜听春雨，深巷明朝卖杏花。<br>　　矮纸斜行闲作草，晴窗细乳戏分茶。<br>　　素衣莫起风尘叹，犹及清明可到家。<br>　　<br>　　<strong>蝶恋花</strong><br>　　禹庙兰亭今古路。一夜清霜，染尽湖边树。鹦鹉杯深君莫诉。他时相遇知何处。<br>　　冉冉年华留不住。镜里朱颜，毕竟消磨去。一句丁宁君记取。神仙须是闲人做。<br>　　<br>　　<strong>秋波媚</strong><br>　　秋到边城角声哀，烽火照高台。悲歌击筑，凭高酹酒，此兴悠哉。<br>　　多情谁似南山月，特地暮云开。灞桥烟柳，曲江池馆，应待人来。 </p>
<p>　　<strong>浣溪沙·和无咎韵</strong><br>　　懒向沙头醉玉瓶，唤君同赏小窗明。夕阳吹角最关情。<br>　　忙日苦多闲日少，新愁常续旧愁生。客中无伴怕君行。 </p>
<h2 id="辛弃疾"><a href="#辛弃疾" class="headerlink" title="辛弃疾"></a>辛弃疾</h2><p>　　你又说陆游随军倒是随了，不过是个参谋。//按古代参谋的职能可能连参谋都算不了 那么肝肠如火的词中之龙呢。
　　</p>
<blockquote>
<p>　　辛弃疾生于金国，少年抗金归宋，曾任江西安抚使、福建安抚使等职。著有《美芹十论》、《九议》，条陈战守之策。由于与当政的主和派政见不合，后被弹劾落职，退隐山居。开禧北伐前后，相继被起用为绍兴知府、镇江知府、枢密都承旨等职。开禧三年（1207年），辛弃疾病逝，年六十八。后赠少师，谥号“忠敏”。<br>　　辛弃疾一生以恢复为志，以功业自许，却命运多舛、备受排挤、壮志难酬。但他恢复中原的爱国信念始终没有动摇，而是把满腔激情和对国家兴亡、民族命运的关切、忧虑，全部寄寓于词作之中。其词艺术风格多样，以豪放为主，风格沉雄豪迈又不乏细腻柔媚之处。其词题材广阔又善化用典故入词，抒写力图恢复国家统一的爱国热情，倾诉壮志难酬的悲愤，对当时执政者的屈辱求和颇多谴责；也有不少吟咏祖国河山的作品。现存词六百多首，有词集《稼轩长短句》等传世。——from baidu</p>
<p>　　在我看到的资料里，辛弃疾至少是快刀利剑地杀过几次人的。他天生孔武高大，从小苦修剑法。他又生于金宋乱世，不满金人的侵略蹂躏，22岁时他就拉起了一支数千人的义军，后又与耿京为首的义军合并，并兼任书记长，掌管印信。一次义军中出了叛徒，将印信偷走，准备投金。辛弃疾手提利剑单人独马追贼两日，第三天提回一颗人头。为了光复大业，他又说服耿京南归，南下临安亲自联络。不想就这几天之内又变生肘腋，当他完成任务返回时，部将叛变，耿京被杀。辛大怒，跃马横刀，只率数骑突入敌营生擒叛将，又奔突千里，将其押解至临安正法，并率万人南下归宋。说来，他干这场壮举时还只是一个英雄少年，正血气方刚，欲为朝廷痛杀贼寇，收复失地。——《把栏杆拍遍》by梁衡
　　</p>
</blockquote>
<p>　　<strong>青玉案·元夕</strong><br>　　东风夜放花千树。更吹落、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。<br>　　蛾儿雪柳黄金缕。笑语盈盈暗香去。众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。</p>
<p> 　　何止有名，别有怀抱。</p>
<p>　　<strong>清平乐·村居</strong><br>　　茅檐低小，溪上青青草。<br>　　醉里吴音相媚好，白发谁家翁媪？<br>　　大儿锄豆溪东，中儿正织鸡笼。<br>　　最喜小儿亡赖，溪头卧剥莲蓬。</p>
<p>　　<strong>西江月·夜行黄沙道中</strong><br>　　明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。<br>　　七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。</p>
<p>　　<strong>丑奴儿·书博山道中壁</strong><br>　　少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。<br>　　而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。 </p>
<p>　　<strong>菩萨蛮·书江西造口壁</strong><br>　　郁孤台下清江水，中间多少行人泪。西北望长安，可怜无数山。<br>　　青山遮不住，毕竟东流去。江晚正愁余，山深闻鹧鸪。</p>
<p>　　<strong>一剪梅·中秋元月</strong><br>　　忆对中秋丹桂丛，花也杯中，月也杯中。今宵楼上一尊同，云湿纱窗，雨湿纱窗。<br>　　浑欲乘风问化工，路也难通，信也难通。满堂唯有烛花红，歌且从容，杯且从容。</p>
<p>　　<strong>摸鱼儿</strong><br>　　淳熙己亥，自湖北漕移湖南，同官王正之置酒小山亭，为赋。<br>　　更能消、几番风雨，匆匆春又归去。惜春长怕花开早，何况落红无数。春且住，见说道、天涯芳草无归路。怨春不语。算只有殷勤，画檐蛛网，尽日惹飞絮。<br>　　长门事，准拟佳期又误。蛾眉曾有人妒。千金纵买相如赋，脉脉此情谁诉？君莫舞，君不见、玉环飞燕皆尘土！闲愁最苦！休去倚危栏，斜阳正在，烟柳断肠处。 </p>
<p>　　<strong>鹧鸪天·代人赋</strong><br>　　晚日寒鸦一片愁。柳塘新绿却温柔。若教眼底无离恨，不信人间有白头。<br>　　肠已断，泪难收。相思重上小红楼。情知已被山遮断，频倚阑干不自由。 </p>
<p>　　<strong>西江月·遣兴</strong><br>　　醉里且贪欢笑，要愁那得工夫。<br>　　近来始觉古人书。信著全无是处。<br>　　昨夜松边醉倒，问松我醉何如。<br>　　只疑松动要来扶。以手推松曰去。 </p>
<p>　　<strong>鹧鸪天·陌上柔桑破嫩芽</strong><br>　　陌上柔桑破嫩芽，东邻蚕种已生些。平冈细草鸣黄犊，斜日寒林点暮鸦。<br>　　山远近，路横斜，青旗沽酒有人家。城中桃李愁风雨，春在溪头荠菜花。 </p>
<p>　　<strong>醉花阴</strong><br>　　黄花谩说年年好。也趁秋光老。绿鬓不惊秋，若斗尊前，人好花堪笑。<br>　　蟠桃结子知多少。家住三山岛。何日跨归鸾，沧海飞尘，人世因缘了。 </p>
<p>　　承焘先生评语的下一句是“色笑如花”啊。</p>
<h2 id="李白"><a href="#李白" class="headerlink" title="李白"></a>李白</h2><p>　　词，不过靡靡之音诗余耳。读诗还需回望你唐。
　　</p>
<blockquote>
<p>　　李白（701年－762年） ，字太白，号青莲居士，又号“谪仙人”，是唐代伟大的浪漫主义诗人，被后人誉为“诗仙”，与杜甫并称为“李杜”，为了与另两位诗人李商隐与杜牧即“小李杜”区别，杜甫与李白又合称“大李杜”。其人爽朗大方，爱饮酒作诗，喜交友。<br>李白深受黄老列庄思想影响，有《李太白集》传世，诗作中多以醉时写的，代表作有《望庐山瀑布》、《行路难》、《蜀道难》、《将进酒》、《梁甫吟》、《早发白帝城》等多首。<br>李白所作词赋，宋人已有传记（如文莹《湘山野录》卷上），就其开创意义及艺术成就而言，“李白词”享有极为崇高的地位。——from baidu</p>
</blockquote>
<p>　　那么曾受金龟换酒的你白却又如何。<br>　　<strong>子夜四时歌四首</strong><br>　　<strong>春歌</strong><br>　　秦地罗敷女，采桑绿水边。<br>　　素手青条上，红妆白日鲜。<br>　　蚕饥妾欲去，五马莫留连。<br>　　<strong>夏歌</strong><br>　　镜湖三百里，菡萏发荷花。<br>　　五月西施采，人看隘若耶。<br>　　回舟不待月，归去越王家。<br>　　<strong>秋歌</strong><br>　　长安一片月，万户捣衣声。<br>　　秋风吹不尽，总是玉关情。<br>　　何日平胡虏，良人罢远征。<br>　　<strong>冬歌</strong><br>　　明朝驿使发，一夜絮征袍。<br>　　素手抽针冷，那堪把剪刀。<br>　　裁缝寄远道，几日到临洮？</p>
<p>　　<strong>关山月</strong><br>　　明月出天山，苍茫云海间。<br>　　长风几万里，吹度玉门关。<br>　　汉下白登道，胡窥青海湾。<br>　　由来征战地，不见有人还。<br>　　戍客望边邑，思归多苦颜。<br>　　高楼当此夜，叹息未应闲。 </p>
<p>　　<strong>秋风词</strong><br>　　秋风清，秋月明，<br>　　落叶聚还散，寒鸦栖复惊。<br>　　相思相见知何日？此时此夜难为情！<br>　　入我相思门，知我相思苦。<br>　　长相思兮长相忆，短相思兮无穷极。<br>　　早知如此绊人心，何如当初莫相识。</p>
<p>　　<strong>清平调</strong><br>　　云想衣裳花想容，春风拂槛露华浓。<br>　　若非群玉山头见，会向瑶台月下逢。 </p>
<p>　　一枝秾艳露凝香，云雨巫山枉断肠。<br>　　借问汉宫谁得似，可怜飞燕倚新妆。</p>
<p>　　名花倾国两相欢，长得君王带笑看。<br>　　解释春风无限恨，沉香亭北倚阑干。</p>
<p>　　<strong>春思</strong><br>　　燕草如碧丝，秦桑低绿枝。<br>　　当君怀归日，是妾断肠时。<br>　　春风不相识，何事入罗帏。<br>　　<br>　　<strong>怨情</strong><br>　　美人卷珠帘，深坐颦蛾眉。<br>　　但见泪痕湿，不知心恨谁。<br>　　<br>　　<strong>玉阶怨</strong><br>　　玉阶生白露，夜久侵罗袜。<br>　　却下水晶帘，玲珑望秋月。<br>　　<br>　　还有这两首吊打后来那些小朋友的词。<br>　　<strong>菩萨蛮</strong><br>　　平林漠漠烟如织，寒山一带伤心碧。暝色入高楼，有人楼上愁。<br>　　玉阶空伫立，宿鸟归飞急。何处是归程？长亭连短亭。<br>　　<strong>忆秦娥</strong><br>　　箫声咽，秦娥梦断秦楼月。秦楼月，年年柳色，灞陵伤别。<br>　　乐游原上清秋节，咸阳古道音尘绝。音尘绝，西风残照，汉家陵阙。 </p>
<p>所以说还是naive,需要学习一个，不要老想把诗词这种思想性与艺术性并重的东西拉过来批判一番它的思想性不高balabala……要思想性高，可以啊，去研究数学哲学，元数学，形式系统的形式系统，符合您的bigger，岂不美哉。</p>
<blockquote>
<p><a href="so.gushiwen.org">诗词来源</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/11/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/11/undefined-title/" itemprop="url">录韦庄作九首</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T19:32:41+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我已经开始放飞自我了。。。</p>
<p>以花间流芳，王观堂语中骨秀的韦端己词自有其妙，我且不做评价，但CV一发。//也是拙笔评价不来</p>
<h2 id="菩萨蛮"><a href="#菩萨蛮" class="headerlink" title="菩萨蛮"></a>菩萨蛮</h2><p><strong>（其一）</strong></p>
<p>红楼别夜堪惆怅，香灯半卷流苏帐。<br>残月出门时，美人和泪辞。<br>琵琶金翠羽，弦上黄莺语。<br>劝我早还家，绿窗人似花。 </p>
<p><strong>（其二）</strong><br>人人尽说江南好，游人只合江南老。<br>春水碧于天，画船听雨眠。<br>垆边人似月，皓腕凝霜雪。<br>未老莫还乡，还乡须断肠。 </p>
<p><strong>（其三）</strong><br>如今却忆江南乐，当时年少春衫薄。<br>骑马倚斜桥，满楼红袖招。<br>翠屏金屈曲，醉入花丛宿。<br>此度见花枝，白头誓不归。 </p>
<p><strong>（其四）</strong><br>劝君今夜须沉醉，尊前莫话明朝事。<br>珍重主人心，酒深情亦深。<br>须愁春漏短，莫诉金杯满。<br>遇酒且呵呵，人生能几何。 </p>
<p><strong>（其五）</strong><br>洛阳城里春光好，洛阳才子他乡老。<br>柳暗魏王堤，此时心转迷。<br>桃花春水渌，水上鸳鸯浴。<br>凝恨对残晖，忆君君不知。 </p>
<p>此乃词作。五篇菩萨蛮可见一斑矣。其诗收录于《浣花集》。</p>
<h2 id="台城"><a href="#台城" class="headerlink" title="台城"></a>台城</h2><p>江雨霏霏江草齐，六朝如梦鸟空啼。<br>无情最是台城柳，依旧烟笼十里堤。 </p>
<h2 id="忆昔"><a href="#忆昔" class="headerlink" title="忆昔"></a>忆昔</h2><p>昔年曾向五陵游，子夜歌清月满楼。<br>银烛树前长似昼，露桃花里不知秋。<br>西园公子名无忌，南国佳人号莫愁。<br>今日乱离俱是梦，夕阳唯见水东流。</p>
<h2 id="关河道中"><a href="#关河道中" class="headerlink" title="关河道中"></a>关河道中</h2><p>槐陌蝉声柳市风，驿楼高倚夕阳东。<br>往来千里路长在， 聚散十年人不同。<br>但见时光流似箭，岂知天道曲如弓。<br>平生志业匡尧舜，又拟沧浪学钓翁。 </p>
<p>然其得名”秦妇吟秀才“之作却未曾收录于集。私以为隐隐有”孤篇盖全集“之意。</p>
<p>//划重点！</p>
<h1 id="秦妇吟"><a href="#秦妇吟" class="headerlink" title="秦妇吟"></a>秦妇吟</h1><p>　　中和癸卯春三月，洛阳城外花如雪。东西南北路人绝，绿杨悄悄香尘灭。路旁忽见如花人，独向绿杨阴下歇。凤侧鸾欹鬓脚斜，红攒黛敛眉心折。借问女郎何处来？含颦欲语声先咽。回头敛袂谢行人，丧乱漂沦何堪说！三年陷贼留秦地，依稀记得秦中事。君能为妾解金鞍，妾亦与君停玉趾。<br>　　前年庚子腊月五，正闭金笼教鹦鹉。斜开鸾镜懒梳头，闲凭雕栏慵不语。忽看门外起红尘，已见街中擂金鼓。居人走出半仓惶，朝士归来尚疑误。是时西面官军入，拟向潼关为警急。皆言博野自相持，尽道贼军来未及。须臾主父乘奔至，下马入门痴似醉。适逢紫盖去蒙尘，已见白旗来匝地。<br>　　扶羸携幼竞相呼，上屋缘墙不知次。南邻走入北邻藏，东邻走向西邻避。北邻诸妇咸相凑，户外崩腾如走兽。轰轰混混乾坤动，万马雷声从地涌。火迸金星上九天，十二官街烟烘烔。日轮西下寒光白，上帝无言空脉脉。阴云晕气若重围，宦者流星如血色。紫气潜随帝座移，妖光暗射台星拆。家家流血如泉沸，处处冤声声动地。舞伎歌姬尽暗捐，婴儿稚女皆生弃。<br>　　东邻有女眉新画，倾国倾城不知价。长戈拥得上戎车，回首香闺泪盈把。旋抽金线学缝旗，才上雕鞍教走马。有时马上见良人，不敢回眸空泪下；西邻有女真仙子，一寸横波剪秋水。妆成只对镜中春，年幼不知门外事。一夫跳跃上金阶，斜袒半肩欲相耻。牵衣不肯出朱门，红粉香脂刀下死。南邻有女不记姓，昨日良媒新纳聘。琉璃阶上不闻行，翡翠帘间空见影。忽看庭际刀刃鸣，身首支离在俄顷。仰天掩面哭一声，女弟女兄同入井；北邻少妇行相促，旋拆云鬟拭眉绿。已闻击托坏高门，不觉攀缘上重屋。须臾四面火光来，欲下回梯梯又摧。烟中大叫犹求救，梁上悬尸已作灰。<br>　　妾身幸得全刀锯，不敢踟蹰久回顾。旋梳蝉鬓逐军行，强展蛾眉出门去。旧里从兹不得归，六亲自此无寻处。一从陷贼经三载，终日惊忧心胆碎。夜卧千重剑戟围，朝餐一味人肝脍。鸳帏纵入岂成欢？宝货虽多非所爱。蓬头垢面眉犹赤，几转横波看不得。衣裳颠倒语言异，面上夸功雕作字。柏台多半是狐精，兰省诸郎皆鼠魅。还将短发戴华簪，不脱朝衣缠绣被。翻持象笏作三公，倒佩金鱼为两史。朝闻奏对入朝堂，暮见喧呼来酒市。<br>　　一朝五鼓人惊起，叫啸喧呼如窃语。夜来探马入皇城，昨日官军收赤水。赤水去城一百里，朝若来兮暮应至。凶徒马上暗吞声，女伴闺中潜生喜。皆言冤愤此时销，必谓妖徒今日死。逡巡走马传声急，又道官军全阵入。大彭小彭相顾忧，二郎四郎抱鞍泣。沉沉数日无消息，必谓军前已衔璧。簸旗掉剑却来归，又道官军悉败绩。<br>　　四面从兹多厄束，一斗黄金一斗粟。尚让厨中食木皮，黄巢机上刲人肉。东南断绝无粮道，沟壑渐平人渐少。六军门外倚僵尸，七架{寨}营中填饿殍。长安寂寂今何有？废市荒街麦苗秀。采樵斫尽杏园花，修寨诛残御沟柳。华轩绣毂皆销散，甲第朱门无一半。含元殿上狐兔行，花萼楼前荆棘满。昔时繁盛皆埋没，举目凄凉无故物。内库烧为锦绣灰，天街踏尽公卿骨！<br>　　来时晓出城东陌，城外风烟如塞色。路旁时见游奕军，坡下寂无迎送客。霸陵东望人烟绝，树锁骊山金翠灭。大道俱成棘子林，行人夜宿墙匡月。明朝晓至三峰路，百万人家无一户。破落田园但有蒿，摧残竹树皆无主。路旁试问金天神，金天无语愁于人。庙前古柏有残枿，殿上金炉生暗尘。一从狂寇陷中国，天地晦冥风雨黑。案前神水咒不成，壁上阴兵驱不得。闲日徒歆奠飨恩，危时不助神通力。我今愧恧拙为神，且向山中深避匿。寰中箫管不曾闻，筵上牺牲无处觅。旋教魔鬼傍乡村，诛剥生灵过朝夕。妾闻此语愁更愁，天遣时灾非自由。神在山中犹避难，何须责望东诸侯！<br>　　　前年又出扬震关，举头云际见荆山。如从地府到人间，顿觉时清天地闲。陕州主帅忠且贞，不动干戈唯守城。蒲津主帅能戢兵，千里晏然无犬声。朝携宝货无人问，暮插金钗唯独行。明朝又过新安东，路上乞浆逢一翁。苍苍面带苔藓色，隐隐身藏蓬荻中。问翁本是何乡曲？底事寒天霜露宿？老翁暂起欲陈辞，却坐支颐仰天哭。乡园本贯东畿县，岁岁耕桑临近甸。岁种良田二百廛，年输户税三千万。小姑惯织褐絁袍，中妇能炊红黍饭。千间仓兮万丝箱，黄巢过后犹残半。自从洛下屯师旅，日夜巡兵入村坞。匣中秋水拔青蛇，旗上高风吹白虎。入门下马若旋风，罄室倾囊如卷土。家财既尽骨肉离，今日垂年一身苦。一身苦兮何足嗟，山中更有千万家，朝饥山上寻蓬子，夜宿霜中卧荻花！<br>　　妾闻此老伤心语，竟日阑干泪如雨。出门惟见乱枭鸣，更欲东奔何处所？仍闻汴路舟车绝，又道彭门自相杀。野宿徒销战士魂，河津半是冤人血。适闻有客金陵至，见说江南风景异。自从大寇犯中原，戎马不曾生四鄙。诛锄窃盗若神功，惠爱生灵如赤子。城壕固护教{斆、敩、效}金汤，赋税如云送军垒。奈何四海尽滔滔，湛然一境平如砥。避难徒为阙下人，怀安却羡江南鬼。愿君举棹东复东，咏此长歌献相公。 </p>
<p><a href="http://www.gushiwen.org/" target="_blank" rel="external">诗词来源</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/10/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/undefined-title/" itemprop="url">欧拉小传</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T19:27:29+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="膜一发欧拉蒟蒟"><a href="#膜一发欧拉蒟蒟" class="headerlink" title="膜一发欧拉蒟蒟"></a>膜一发欧拉蒟蒟</h2><p>(什么时候才能自信地叫出”欧拉老师”呢//一声叹息)</p>
<p>欧拉，L．(Euler，Leonhard)1707年4月15日生于瑞士巴塞尔；1783年9月18日卒于俄国圣彼得堡．数学、力学、天文学、物理学． </p>
<p>欧拉的祖先原来居住在瑞士东北部博登湖(康斯坦斯湖)畔的小城——林道．16世纪末，他的曾祖父汉斯·乔治·欧拉(HansGeorg Euler)带领全家顺莱茵河而下，迁居巴塞尔．这个家族几代人多为手艺劳动者．欧拉的父亲保罗·欧拉(Paul Euler)则毕业于巴塞尔大学神学系，是基督教新教的牧师．1706年，保罗与另一位牧师的女儿玛格丽特·勃鲁克(Margarete Brucker)结婚．翌年春，欧拉降生．1708年，保罗举家迁居巴塞尔附近的村庄——里亨(Riehen)．欧拉就在这田园静谧的乡村度过他的童年．</p>
<p>欧拉的父亲很喜爱数学．还在大学读书时，他就常去听雅格布·伯努利(Jakob Bernouli)的数学讲座．他亲自对欧拉进行包括数学在内的启蒙教育，并盼望儿子成为教门的后起之秀．贤惠的母亲为了使欧拉及时受到良好的学校教育，把他送到巴塞尔外祖母家生活了几年，入那里的一所文科中学念书．可是，这所学校不教数学．勤勉好学的欧拉独自随业余数学家J．伯克哈特(Bu-rckhart)学习．欧拉聪敏早慧，酷爱数学．他曾下苦功研读C．鲁道夫(Rudolf)的《代数学》(Algebra，1553)达数年之久．</p>
<p>1720年秋，年仅13岁的欧拉进了巴塞尔大学文科．当时，约翰·伯努利(Johann Bernoulli)任该校数学教授．他每天讲授基础数学课程，同时还给那些有兴趣的少数高材生开设更高深的数学、物理学讲座．欧拉是约翰·伯努利的最忠实的听众．他勤奋地学习所有的科目，但仍不满足．欧拉后来在自传中写道：“……不久，我找到了一个把自己介绍给著名的约翰·伯努利教授的机会．……他确实忙极了，因此断然拒绝给我个别授课．但是，他给了我许多更加宝贵的忠告，使我开始独立地学习更困难的数学著作，尽我所能努力地去研究它们．如果我遇到什么障碍或困难，他允许我每星期六下午自由地去找他，他总是和蔼地为我解答一切疑难……无疑，这是在数学学科上获得成功的最好的方法．”约翰的两个儿子尼吉拉·伯努利第二(Nikolaus Bernoulli II)、丹尼尔·伯努利(Daniel Bernoulli)，也成了欧拉的挚友．</p>
<p>1722年夏，欧拉在巴塞尔大学获学士学位．翌年，他又获哲学硕士学位．但授予这一学位是在1724年6月8日的会议上正式通告的．此前，他为了满足父亲的愿望，于1723年秋又入神学系．他在神学、希腊语、希伯莱语方面的学习并不成功．他仍把大部分时间花在数学上．尽管欧拉后来彻底放弃了当牧师的念头，但他却终生虔诚地信奉基督教．</p>
<p>欧拉18岁开始其数学研究生涯．1726年，他在《博学者》(Acta eruditorum)上发表了关于在有阻尼的介质中的等时曲线结构问题的文章．翌年，他研究弹道问题和船桅的最佳布置问题．后者是这年巴黎科学院的有奖征文课题．欧拉的论文虽未获得奖金，却得到了荣誉提名．此后，从1738年至1772年，欧拉共获得巴黎科学院12次奖金．</p>
<p>在瑞士，当时青年数学家的工作条件非常艰难，而俄国新组建的圣彼得堡科学院正在网罗人才．1725年秋，尼古拉第二和丹尼尔应聘前往俄国，并向当局力荐欧拉．翌年秋，欧拉在巴塞尔收到圣彼得堡科学院的聘书，请他去那里任生理学院士助理．然而，故土难离．欧拉开始用数学和力学方法研究生理学，同时仍期望在巴塞尔大学找到职位．恰好，这时该校有一位物理学教授病故，出现空席．欧拉向学校教授评议会递交了“论声音的物理学原理”(Dissertatio physica de sono，1727)的论文，争取教授资格．在激烈的竞争中，未满20岁的欧拉落选了．1727年4月5日欧拉告别故乡，5月24日抵达圣彼得堡．从那时起，欧拉的一生和他的科学工作都紧密地同圣彼得堡科学院和俄国联系在一起．他再也没有回过瑞士．但是，出于对祖国的深厚感情，欧拉始终保留了他的瑞士国籍．</p>
<p>欧拉到达圣彼得堡后，立即开始研究工作．不久，他获得了在真正擅长的领域从事研究工作的机会．1727年，他被任命为科学院数学部助理院士．他撰写的关于圣彼得堡科学院学术会议情况的调查报告，也开始在《圣彼得堡科学院汇刊(1727)》(Comme－ntarii Academiae scientiarum imperialis Petropolitanae)第二卷(St．Petersburg，1729)上发表．尽管那些年俄国政局动荡，圣彼得堡科学院还处在艰难岁月之中，但周围的学术气氛对发展欧拉的才华特别有利．那里聚集着一群杰出的科学家，如数学家C．哥德巴赫(Goldbach)、丹尼尔·伯努利，力学家J．赫尔曼(Hermann)，三角学家F．梅尔(Maier)，天文学家和地理学家J．N．德莱索(Delisle)等．他们同欧拉的个人情谊与共同的科学兴趣，使得彼此在科研工作中配合默契、相得益彰．1731年，欧拉成为物理学教授．1733年，丹尼尔·伯努利返回巴塞尔后，欧拉接替了他的数学教授职务，担负起领导科学院数学部的重任．这对亲密的朋友，以后通信40多年，促进了科学的竞争和发展．是年冬，欧拉和科学院预科学校的美术教师、瑞士画家G．葛塞尔(Gsell)的女儿柯黛林娜·葛塞尔(Katharina Gsell)结婚．翌年，其长子约翰·阿尔勃兰克(Johann Albrecht)降生．1740年，卡尔(Karl)出世．恬静、美满的家庭生活伴随着欧拉科学生涯的第一个黄金时期．</p>
<p>还在圣彼得堡科学院建成之初，俄国政府就责成它除了进行纯科学研究之外，还要培养、训练俄国科学家．为此，科学院建立了一所大学和预科学校，大学办了近50年，预科学校一直办到1805年．俄国政府还委托科学院制定俄国的地图，解决各种具体技术问题．欧拉积极参与并领导了科学院的这些工作．从1733年起，他和德莱索成功地进行了地图研究．从30年代中期开始，欧拉以极大的精力研究航海和船舶建造问题．这些问题对于俄国成为海上强国，是具有重大意义的．欧拉是各种技术委员会的成员，又担任科学院考试委员会委员．他既要为科学院的期刊撰稿、审稿，还要为附属大学、预科学校准备讲义、开设讲座，工作十分忙碌．然而，他的主要成就是在数学研究上．</p>
<p>在圣彼得堡的头14年间，欧拉以无可匹敌的工作效率在分析学、数论和力学等领域作出许多辉煌的发现．截止1741年，他完成了近90种著作，公开发表了55种，其中包括1936年完成的两卷本《力学或运动科学的分析解说》(Mechanica sive motus scie－ntia analytice exposita)．他的研究硕果累累，声望与日俱增，赢得了各国科学家的尊敬．欧拉从前的导师约翰·伯努利早在1728年的信中就称他为“最善于学习和最有天赋的科学家”，1737年又称他是“最驰名和最博学的数学家”．欧拉后来谦逊地说：“……我和所有其他有幸在俄罗斯帝国科学院工作过一段时间的人都不能不承认，我们应把所获得的一切和所掌握的一切归功于我们在那儿拥有的有利条件．”<br>由于过度的劳累，1738年，欧拉在一场疾病之后右眼失明了．但他仍旧坚韧不拔地工作．他热爱科学，热爱生活．他非常喜欢孩子(他一生有过13个孩子，除了5个以外都夭亡了)．写论文时往往膝上抱着婴儿，大一点的孩子则绕膝戏耍．他酷爱音乐．在撰写艰深的数学论文时，他的“那种轻松自如是令人难以置信的”．</p>
<p>1740年秋冬，俄国政局再度骤变，形势极不安定．欧拉此时与圣彼得堡科学院粗鲁、专横的顾问J．D．舒马赫尔(Schuma－cher)也产生了磨擦．为了使自己的科学事业不受损害，欧拉希望寻求新的出路．恰好这年夏天继承了普鲁士王位的腓特烈(Frederick)大帝决定重振柏林科学院，他热情邀请欧拉去柏林工作．欧拉接受了邀请．1741年6月19日，欧拉启程离开圣彼得堡，7月25日抵达柏林．</p>
<p>柏林科学院是在G．W．莱布尼茨(Leibniz)的大力推动下于1700年创立的，后来它衰落了．欧拉在柏林25年．那时，他精力旺盛，不知疲倦地工作．他鼎力襄助院长P．莫佩蒂(Maupe－rtuis)，在恢复和发展柏林科学院的工作中发挥了重大作用．</p>
<p>在柏林，欧拉任科学院数学部主任．他是科学院的院务委员、图书馆顾问和学术著作出版委员会委员．他还担负了其他许多行政事务，如管理天文台和植物园，提出人事安排，监督财务，以及历书和地图的出版工作．当院长莫佩蒂外出期间，欧拉代理院长．1759年莫佩蒂去世后，虽然没有正式任命欧拉为院长，但他实际上一直领导着科学院的工作．欧拉和莫佩蒂的友谊，使欧拉能对柏林科学院的一切活动，尤其是在选拔院士方面，施加巨大影响．</p>
<p>欧拉还担任过普鲁士政府关于安全保险、退休金和抚恤金等问题的顾问，并为腓特烈大帝了解火炮方面的最新成果(1745年)，设计改造费诺运河(1749年)，曾主管普鲁士皇家别墅水力系统管系和泵系的设计工作．他和德国许多大学的教授保持广泛联系，对大学教科书的编写和数学教学起了促进作用．</p>
<p>在此期间，欧拉一直保留着圣彼得堡科学院院士资格，领取年俸．受该院委托，欧拉为其编纂院刊的数学部分，介绍西欧的科学思想，购买书籍和科学仪器，同时推荐研究人员和课题．他在培养俄国的科学人才方面起了重大的作用．他还经常把自己的学术论文寄往圣彼得堡．他的论文约有一半是用拉丁文在圣彼得堡发表的，另一半用法文在柏林出版．另外，他还先后当选为伦敦皇家学会会员(1749年)、巴塞尔物理数学会会员(1753年)及巴黎科学院院士(1755年)．</p>
<p>柏林时期是欧拉科学研究的鼎盛时期，其研究范围迅速扩大．他与J．K．达朗贝尔(D’Alembert)和丹尼尔·伯努利展开的学术竞争奠定了数学物理的基础；他与A．克莱罗(Clairaut)和达朗贝尔一起推进了月球和行星运动理论的研究．与此同时，欧拉详尽地阐述了刚体运动理论，创立了流体动力学的数学模型，深入地研究了光学和电磁学，以及消色差折射望远镜等许多技术问题．他写了大约380篇(部)论著，出版了其中的275种．内有分析学、力学、天文学、火炮和弹道学、船舶建造和航海等方面的几部巨著，其中1748年出版的两卷集著作《无穷分析引论》(Introdu－ctio in analysin infinitorum)在数学史上占有十分重要的地位．</p>
<p>欧拉参加了18世纪40年代关于莱布尼茨和C．沃尔夫(Wolff)的单子论的激烈辩论．欧拉在自然哲学方面接近R．笛卡儿(Descartes)的机械唯物主义，他和莫佩蒂都是单子论的“劲敌”．1751年，S．柯尼格(K nig)以耸入听闻的新论据，发表了几篇批评莫佩蒂的“最小作用原理”的文章．欧拉翌年撰文反驳，并同莫佩蒂用更浅显的语言来解释最小作用原理．除了这些哲学和科学的争论以外，对于数学的发展来说，欧拉参加了另外三场更重要的争论：与达朗贝尔关于负数对数的争论；与达朗贝尔、丹尼尔·伯努利关于求解弦振动方程的争论；与J．多伦(Dollond)关于光学问题的争论．</p>
<p>1759年莫佩蒂去世后，欧拉在普鲁士国王的直接监督之下负责柏林科学院的工作．欧拉同腓特烈大帝之间的关系并不融洽．1763年，当获悉腓特烈想把院长的职务授予达朗贝尔后，欧拉开始考虑离开柏林．圣彼得堡科学院立即遵照卡捷琳娜(Catherine)女皇旨意寄给欧拉聘书，诚挚希望他重返圣彼得堡．但是达朗贝尔拒绝长期移居柏林，使腓特烈一度推迟就院长入选作最后的决定．“七年战争”之后，腓特烈粗暴地干涉欧拉对柏林科学院的事务管理．1765年至1766年，在财政问题上，欧拉与腓特烈之间引发了一场严重的冲突．他恳请普鲁士国王同意他离开柏林．1766年7月28日，欧拉重返圣彼得堡，他的三个儿子和两个女儿也回到俄国，伴于身旁．</p>
<p>欧拉的家安置在涅瓦河畔离圣彼得堡科学院不远的舒适之处．他的长子阿尔勃兰克这年成为科学院院士、物理学部教授，三年后又被任命为科学院的终身秘书．1766年，欧拉父子还同时当选为科学院执行委员．欧拉的工作是顺心的，然而，厄运也接二连三地向他袭来．回到圣彼得堡不久，一场疾病使欧拉的左眼几乎完全失明．这时，他已经不能再看书了．只能勉强看清大字体的提纲，用粉笔在石板上写很大的字母．1771年，欧拉双目完全失明．这一年，圣彼得堡的一场特大火灾又使欧拉的住所和财产付之一炬，仅抢救出欧拉及其手稿． 1773年 11月，欧拉夫人柯黛琳娜去世．三年后，她同父异母的妹妹莎洛姆·葛塞尔(SalomeGsell)成为欧拉的第二个妻子．</p>
<p>欧拉晚年遭受双目失明、火灾和丧偶的沉重打击，他仍不屈不挠地奋斗，丝毫没有减少科学活动．在他的周围，有一群主动的合作者，包括：他的儿子阿尔勃兰克和克利斯朵夫(Christoph)； W．L．克拉夫特(Krafft)院士和A．J．莱克塞尔(Lexell)院士；两位年轻的助手N．富斯(Fuss)和M．E．哥洛文(Golovin)．欧拉和他们一起讨论著作出版的总计划，有时简要地口述研究成果．他们则使欧拉的设想变得更加明确，有时还为欧拉的论著编纂例证．据富斯自己统计，七年内他为欧拉整理论文250篇，哥洛文整理了70篇．欧拉非常尊重别人的劳动．1772年出版的《月球运动理论和计算方法》(Theoria motuum lunae， nova methodoPertractata)是在阿尔勃兰克、克拉夫特和莱克塞尔的帮助下完成的，欧拉把他们的名字都印在这本书的扉页上．</p>
<p>重返圣彼得堡后，欧拉的著作出版得更多．他的论著几乎有一半是1765年以后出版的．其中，包括他的三卷本《积分学原理》(Institutiones calculi integralis， 1768—1770)和《关于物理学和哲学问题给德韶公主的信》(Lettresà une princesse d’AllemagneSur divers sujets de physique et de philosophie， 1768—1772)．前者的最重要部分是在柏林完成的．后者产生于欧拉给普鲁士国王的侄女的授课内容．这本文笔优雅、通俗易懂的科学著作出版后，很快就在欧洲翻译成多种文字，畅销各国，经久不衰．欧拉是历史上著作最多的数学家．</p>
<p>欧拉的多产也得益于他一生非凡的记忆力和心算能力．他70岁时还能准确地回忆起他年轻时读的荷马史诗《伊利亚特》(Iliad)每页的头行和末行．他能够背诵出当时数学领域的主要公式和前100个素数的前六次幂．M．孔多塞(Condorcet)讲述过一个例子，足以说明欧拉的心算本领：欧拉的两个学生把一个颇为复杂的收敛级数的17项相加起来，算到第50位数字时因相差一个单位而产生了争执．为了确定谁正确，欧拉对整个计算过程进行心算，最后把错误找出来了．</p>
<p>1783年9月18日，欧拉跟往常一样，度过了这一天的前半天．他给孙女辅导了一节数学课，用粉笔在两块黑板上作了有关气球运动的计算，然后同莱克塞尔和富斯讨论两年前F．W．赫歇尔(Herschel)发现的天王星的轨道计算．大约下午5时，欧拉突然脑出血，他只说了一句“我要死了”，就失去知觉．晚上11时，欧拉停上了呼吸．</p>
<p>欧拉逝世不久，富斯和孔多塞分别在圣彼得堡科学院和巴黎科学院的追悼会上致悼词．孔多塞在悼词的结尾耐人寻味地说：“欧拉停止了生命，也停止了计算．”</p>
<p>欧拉的菩作在他生前已经有多种输入了中国，其中包括著名的、1748年初版本的《无穷分析引论》．这些著作有一部分曾藏于北京北堂图书馆．它们是18世纪40年代由圣彼得堡科学院赠给北京耶稣会或北京南堂耶稣学院的．这也是中俄数学早期交流的一个明证．19世纪70年代，清代数学家华蘅芳和英国人傅兰雅(John Fryer)合译的《代数术》(1873)和《微积溯源》(1874)，都介绍了欧拉学说．在此前后，李善兰和伟烈亚力(Alexander Wylie)合译的《代数学》(1859)、赵元益译的《光学》(1876)、黄钟骏的《畴人传四编》(1898)等著作也记载了欧拉学说或欧拉的事迹(详见文献［32］)．中国人民是很早就熟悉欧拉的．欧拉不仅属于瑞士，也属于整个文明世界．著名数学史家A．П．尤什凯维奇(Юшкевич)说，人们可以借B．丰唐内尔(Fontenelle)评价莱布尼茨的话来评价欧拉，“他是乐于看到自己提供的种子在别人的植物园里开花的人．”</p>
<p>在欧拉的全部科学贡献中，其数学成就占据最突出的地位．他在力学、天文学、物理学等方面也闪现着耀眼的光芒．<br><a href="http://www.unjs.com/amathematics2/sx/amathematics2_9977.html" target="_blank" rel="external">来源</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/08/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/08/undefined-title/" itemprop="url">求素数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T17:01:23+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>码一波求1-n之间素数的办法。。。。</p>
<h2 id="硬刚解法–n-n-2"><a href="#硬刚解法–n-n-2" class="headerlink" title="硬刚解法–n,n/2"></a>硬刚解法–n,n/2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> i,n;</div><div class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">  &#123;   <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">         <span class="keyword">if</span>(n%i==<span class="number">0</span>)    <span class="keyword">break</span>; </div><div class="line">      <span class="keyword">if</span>(i==n)    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">      <span class="keyword">else</span>           <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是理所当然的想法，按照素数的定义，除了1和它本身没有其他的因数，就是素数。<br>这种解法的缺点就是循环规模n稍微大点，运行时间。。。<br>只需要简单思索就能考虑到，n的因数是成对出现的，如(2,n/2),(3,n/3)等等，因此只枚举i最大到sqr(n)即可退出循环。这里需要注意浮点误差，一般我们用：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=(<span class="built_in">sqrt</span>(n)+<span class="number">0.5</span>);<span class="built_in">i</span>++)</div></pre></td></tr></table></figure>
<p>硬刚解法估计只能在入门题中使用。。。也就是对于某些数据量小且n小的题目。。还是有奇效的//我就是在说你校的比赛题<br>emmm…但不是所有题都对菜鸡这么友好的。。我们还可以在时间上改进算法。</p>
<h2 id="普通筛选法–埃拉托色尼筛法"><a href="#普通筛选法–埃拉托色尼筛法" class="headerlink" title="普通筛选法–埃拉托色尼筛法"></a>普通筛选法–埃拉托色尼筛法</h2><p>基本思想：素数的倍数一定不是素数<br>实现方法：用一个长度为N+1的bool数组保存信息（0表示素数，1表示非素数），先假设所有的数都是素数（初始化为0），从第一个素数2开始，把2的倍数都标记为非素数（置为1），一直到大于N；然后进行下一趟，找到2后面的下一个素数3，进行同样的处理，直到最后，数组中依然为0的数即为素数。<br>说明：整数1特殊处理即可。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">bool judge[n+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">int tot = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">2</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>)</div><div class="line">&#123;</div><div class="line">  if (!judge[i])</div><div class="line">  &#123;</div><div class="line">    prime[tot++] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="built_in">i</span>; <span class="built_in">j</span> &lt;= n; <span class="built_in">j</span> += <span class="built_in">i</span>)</div><div class="line">  &#123;</div><div class="line">    judge[j] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然打表打一次就够了。。。判断n以内一个数是不是指数直接judge[]就可以了。<br>但是我们大概算一下就会发现时间复杂度也不少。。。比如1e8,就是1e8*(1/2+1/3+1/5+1/7+1/11+…..)循环次数，前三个数加起来就以及1e8了，还不算判断时间。。。emmm 当然慢也很好解释，比如说一个合数30030，它分别在(2,3,5,7,9,11,13)时筛了一共是七次。。。emmm….更大的就更不用说了。。。</p>
<p>能不能再给力点呢？</p>
<h2 id="线性筛法–欧拉筛法"><a href="#线性筛法–欧拉筛法" class="headerlink" title="线性筛法–欧拉筛法"></a>线性筛法–欧拉筛法</h2><p>原理：每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次，所以时间复杂度近似是O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>;</div><div class="line"><span class="keyword">bool</span> a[N+<span class="number">1</span>];</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(a,<span class="literal">true</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</div><div class="line">  &#123;    </div><div class="line">      <span class="keyword">if</span>(a[i]) prime.push_back(i);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;prime.size()&amp;&amp;i*prime[j]&lt;=N;j++)</div><div class="line">    &#123; </div><div class="line">        a[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">      <span class="keyword">if</span>(!(i%prime[j])) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>节省空间的写法(少一个bool数组)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e7</span> + <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="built_in">memset</span>(prime, <span class="number">0</span>, <span class="keyword">sizeof</span>(prime));</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= MAXN;i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!prime[i])prime[++prime[<span class="number">0</span>]] = i;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= prime[<span class="number">0</span>] &amp;&amp; prime[j] &lt;= MAXN / i;j++) &#123;</div><div class="line">      prime[prime[j] * i] = <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>1e8的情况是筛选法完全无法满足的，但是还是考虑a * b = c的情况，1e8只需要考虑10000以内的素数p[10000]，然后每次先减去n / p[i]，再加上n / (p[i] * p[j])再减去n / (p[i] * p[j] * p[k])以此类推…于是就可以得到正确结果了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> sqrn, n, ans = <span class="number">0</span>;</div><div class="line"><span class="keyword">bool</span> vis[maxn];</div><div class="line"><span class="keyword">int</span> pri[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!vis[i]) pri[k++] = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; pri[j] * i &lt; maxn; j++)&#123;</div><div class="line">            vis[pri[j] * i] = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> res, <span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; pri[i] &lt;= sqrn; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="number">1L</span>L * res * pri[i] &gt; n)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dfs(num + <span class="number">1</span>, res * pri[i], i+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">            ans -= n / (res * pri[i]);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            ans += n / (res * pri[i]);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) ans++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    init();</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</div><div class="line">        ans = n;</div><div class="line">        sqrn = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)n);</div><div class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Meissel-Lehmer算法"><a href="#Meissel-Lehmer算法" class="headerlink" title="Meissel-Lehmer算法"></a>Meissel-Lehmer算法</h2><p>最后介绍的这个算法可以说是黑科技级别的，它能够在3s内求出1e11之内的素数个数。据说还有在300ms内求出1e11的个数的。可以参考<a href="https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0%E8%AE%A1%E6%95%B0%E5%87%BD%E6%95%B0" target="_blank" rel="external">wiki</a>里面原理。然后给出来自Codeforces 665F题目里面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100    <span class="comment">// pre-calc max n for phi(m, n)</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10010 <span class="comment">// pre-calc max m for phi(m, n)</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXP 40000 <span class="comment">// max primes counter</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 400010    <span class="comment">// max prime</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 <span class="meta-string">&lt;&lt; (((i) &gt;&gt; 1) &amp; 31)))) </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 <span class="meta-string">&lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> pcf &#123;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN][MAXM];</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ar[(MAX &gt;&gt; <span class="number">6</span>) + <span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">  <span class="keyword">int</span> len = <span class="number">0</span>, primes[MAXP], counter[MAX];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</div><div class="line">    setbit(ar, <span class="number">0</span>), setbit(ar, <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; (i * i) &lt; MAX; i++, i++) &#123;</div><div class="line">      <span class="keyword">if</span> (!chkbit(ar, i)) &#123;</div><div class="line">        <span class="keyword">int</span> k = i &lt;&lt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i * i); j &lt; MAX; j += k) setbit(ar, j);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX; i++) &#123;</div><div class="line">      counter[i] = counter[i - <span class="number">1</span>];</div><div class="line">      <span class="keyword">if</span> (isprime(i)) primes[len++] = i, counter[i]++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    Sieve();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; MAXN; n++) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; MAXM; m++) &#123;</div><div class="line">        <span class="keyword">if</span> (!n) dp[n][m] = m;</div><div class="line">        <span class="keyword">else</span> dp[n][m] = dp[n - <span class="number">1</span>][m] - dp[n - <span class="number">1</span>][m / primes[n - <span class="number">1</span>]];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</div><div class="line">    <span class="keyword">if</span> (primes[n - <span class="number">1</span>] &gt;= m) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (m &lt; MAXM &amp;&amp; n &lt; MAXN) <span class="keyword">return</span> dp[n][m];</div><div class="line">    <span class="keyword">return</span> phi(m, n - <span class="number">1</span>) - phi(m / primes[n - <span class="number">1</span>], n - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Lehmer</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (m &lt; MAX) <span class="keyword">return</span> counter[m];</div><div class="line"></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w, res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i, a, s, c, x, y;</div><div class="line">    s = <span class="built_in">sqrt</span>(<span class="number">0.9</span> + m), y = c = cbrt(<span class="number">0.9</span> + m);</div><div class="line">    a = counter[y], res = phi(m, a) + a - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="引申–求欧拉函数"><a href="#引申–求欧拉函数" class="headerlink" title="引申–求欧拉函数"></a>引申–求欧拉函数</h2><p>在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler’s totient function、φ函数、欧拉商数等。</p>
<p>//来自约三百年前的碾压</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define MAXN 100005</span></div><div class="line"><span class="comment">#define MAXL 1299710</span></div><div class="line">int prime[MAXN]<span class="comment">;</span></div><div class="line">int check[MAXL]<span class="comment">;</span></div><div class="line">int phi[MAXL]<span class="comment">;</span></div><div class="line">int tot = <span class="number">0</span><span class="comment">;</span></div><div class="line">phi[<span class="number">1</span>] = <span class="number">1</span><span class="comment">;</span></div><div class="line">memset(check, <span class="number">0</span>, sizeof(check))<span class="comment">;</span></div><div class="line">for (int i = <span class="number">2</span><span class="comment">; i &lt; MAXL; ++i)</span></div><div class="line">&#123;</div><div class="line">  if (!check[i])</div><div class="line">  &#123;</div><div class="line">    prime[tot++] = i<span class="comment">;</span></div><div class="line">    phi[i] = i - <span class="number">1</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  for (int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; tot; ++j)</span></div><div class="line">  &#123;</div><div class="line">    if (i * prime[<span class="keyword">j] </span>&gt; MAXL)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>   &#125;</div><div class="line">    check[i*prime[<span class="keyword">j]] </span>= <span class="number">1</span><span class="comment">;</span></div><div class="line">    if (i % prime[<span class="keyword">j] </span>== <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      phi[i*prime[<span class="keyword">j]] </span>= phi[i] * prime[<span class="keyword">j];</span></div><div class="line"><span class="keyword"> </span>     <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>   &#125;else</div><div class="line">    &#123;</div><div class="line">      phi[i*prime[<span class="keyword">j]] </span>= phi[i] * (prime[<span class="keyword">j]-1);</span></div><div class="line"><span class="keyword"> </span>   &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/grubbyskyer/p/3852421.html" target="_blank" rel="external">https://www.cnblogs.com/grubbyskyer/p/3852421.html</a><br><a href="http://blog.csdn.net/snow_me/article/details/52588819" target="_blank" rel="external">http://blog.csdn.net/snow_me/article/details/52588819</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/07/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/undefined-title/" itemprop="url">natural number</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T19:52:53+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天又要摸鱼了。。。<br>早在小学时我们就学过自然数的定义：</p>
<blockquote>
<p>自然数用以计量事物的件数或表示事物次序的数。即用数码0，1，2，3，4，……所表示的数。</p>
</blockquote>
<p>换言之，自然数即“自然”数。<br>这话拿来糊弄小学生还则罢了，现在来看？？？黑人问号？？？<br>有感于白学的号召，今天来重拾一波被我丢下许久的数学//对不起请蹂躏我</p>
<h2 id="首先给出数论框架的自然数定义，即著名的皮亚诺公理系统"><a href="#首先给出数论框架的自然数定义，即著名的皮亚诺公理系统" class="headerlink" title="首先给出数论框架的自然数定义，即著名的皮亚诺公理系统"></a>首先给出<strong>数论</strong>框架的自然数定义，即著名的<strong>皮亚诺公理系统</strong></h2><p>//因为markdown对公式不友好。。我tm。。。只好用语言描述了。。。</p>
<ul>
<li>PA1:1是自然数。</li>
<li>PA2:对于任意自然数n,其后继数n’均为自然数。</li>
<li>PA3:对于任意自然数n,n’!=1均成立。</li>
<li>PA4:对于任意自然数m,n,若m’=n’,则m=n。   </li>
<li>PA5:假设对自然数n的谓词P(n)而言，下面的(a)和(b)都成立:<br>(a)P(1);<br>(b)对于任意自然数k,P(k)成立，则P(k’)成立。<br>此时对于任意自然数n,P(n)成立。</li>
</ul>
<p>一点微小的说明:</p>
<ol>
<li>PA1和PA3定义了自然数的元。此处采用经典式以1为元，也可以改为0。</li>
<li>PA2和PA4保证了自然数列对唯一的节点不会有两条等长子列相交。//这个表述好别扭啊</li>
<li>PA5即<strong>数学归纳法</strong>。</li>
</ol>
<p>然后我们定义加法公理和乘法公理：</p>
<ol>
<li>对于任意自然数n,n+1=n’。</li>
<li>对于任意自然数m,n,m+n’=(m+n)’。</li>
<li>对于任意自然数n,n*1=n。</li>
<li>对于任意自然数m,n,m<em>n’=(m</em>n)+m。</li>
</ol>
<p>这样，我们只需要分别定义不同的自然数值为2,3,4等即可。</p>
<h2 id="那么我们如何以集合论的观点看待自然数呢？"><a href="#那么我们如何以集合论的观点看待自然数呢？" class="headerlink" title="那么我们如何以集合论的观点看待自然数呢？"></a>那么我们如何以<strong>集合论</strong>的观点看待自然数呢？</h2><p>首先改写皮亚诺公理系统：</p>
<ol>
<li>初始元e是集合M的元素。</li>
<li>集合M对映射F封闭。</li>
<li>e无法经映射F得到。</li>
<li>F是单射。</li>
<li><p>A是M的子集且e是A的元素且A在F下封闭，则A=M。//集合的任何子集不能完成该集合的全部功能</p>
<p>定义新运算：A的后继=A并{A}；<br>归纳集：A对后继运算封闭且空集是A的元素(不是子集)。<br>传递集：A中的任何元素中的元素仍然是A的元素。<br>定义：自然数集是最小的归纳集。同时是传递集。<br>同理使用递归方法就可以定义自然数的加法和乘法了emmm。<br><strong>第二数学归纳法:</strong><br>(a)P(0)成立。<br>(b)对于任意a&lt;b,P(a)成立，那么P(b)成立。<br>后面一步常常分解为两种情况：<br>能应用和一般的归纳法相似的方法的后继序数（有直接前驱的序数）。没有前驱序数的极限序数可以通过将极限序数b看成所有小于b的序数的极限来处理：假定在所有的a&lt;b中P(a)成立，取所有这些情况的极限（通常通过并集公理实现），则证明了P(b)。</p>
</li>
</ol>
<p>参考：</p>
<blockquote>
<p>数学女孩by<a href="http://www.hyuki.com/" target="_blank" rel="external">结城浩</a>，</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/06/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/undefined-title/" itemprop="url">快速幂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T21:49:59+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="摸一发快速幂"><a href="#摸一发快速幂" class="headerlink" title="摸一发快速幂"></a>摸一发快速幂</h2><p>标准快速幂的原理就是把指数拆成二进制减少乘法次数。直接放代码实现了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(b)&#123;</div><div class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">        　　ans*=a;</div><div class="line">        a*=a;</div><div class="line">        b&gt;&gt;=<span class="number">1</span>;</div><div class="line">　 &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然运算量减少了许多。在大指数幂的时候尤为突出。//其实这样能不能做一个推广？在大指数幂的时候用十进制来乘呢？算术运算次数小应该能弥补逻辑运算量太大的不足？</p>
<p>当然在实操中还会用到<strong>取模</strong>这个操作。我们可以根本不去考虑乘方运算取模法则：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> mi(<span class="built_in">int</span> a,<span class="built_in">int</span> b)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> ans=<span class="number">1</span><span class="comment">;</span></div><div class="line">    a%=<span class="built_in">mod</span><span class="comment">;</span></div><div class="line">    <span class="keyword">while</span> (b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) ans=ans*a%<span class="built_in">mod</span><span class="comment">;</span></div><div class="line">        b&gt;&gt;=<span class="number">1</span><span class="comment">;</span></div><div class="line">        a=a*a%<span class="built_in">mod</span><span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理我们可以将加法分解为快速加法。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ll </span><span class="keyword">multi(ll </span>a,<span class="keyword">ll </span><span class="keyword">b,ll </span>p) </div><div class="line">&#123; </div><div class="line">    a=a%p<span class="comment">; </span></div><div class="line">    <span class="keyword">b=b%p; </span></div><div class="line">    <span class="keyword">ll </span>ans=<span class="number">0</span><span class="comment">; </span></div><div class="line">    while(<span class="keyword">b&gt;0) </span></div><div class="line">    &#123;  </div><div class="line">        if(<span class="keyword">b&amp;1==1) </span>   </div><div class="line">        &#123;             </div><div class="line">            ans+=a<span class="comment">;     </span></div><div class="line">            ans%=p<span class="comment">;    </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">b=b&gt;&gt;1; </span> </div><div class="line">        a=a+a<span class="comment">;  </span></div><div class="line">        a=a%p<span class="comment">; </span></div><div class="line">    &#125;    </div><div class="line">    return ans<span class="comment">; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这算是简单的快速幂变形了。然鹅还有一个大boss：</p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>矩阵运算的朴素算法如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const int N=100;</div><div class="line">int c[<span class="string">N</span>][<span class="symbol">N</span>];</div><div class="line">void multi(int a[<span class="string"></span>][<span class="symbol">N</span>],int b[][N],int n)</div><div class="line">&#123;</div><div class="line"><span class="code">    memset(c,0,sizeof c);</span></div><div class="line"><span class="code">    for(int i=1;i&lt;=n;i++)</span></div><div class="line"><span class="code">        for(int j=1;j&lt;=n;j++)</span></div><div class="line"><span class="code">        for(int k=1;k&lt;=n;k++)</span></div><div class="line"><span class="code">        c[i][j]+=a[i][k]*b[k][j];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然此算法的复杂度是O(n^3)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> tmp[N][N];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a[][N],<span class="keyword">int</span> b[][N],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</div><div class="line">        tmp[i][j]+=a[i][k]*b[k][j];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">        a[i][j]=tmp[i][j];</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> res[N][N];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a[][N],<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span> res);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res[i][i]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(n)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</div><div class="line">            multi(res,a,n);<span class="comment">//res=res*a;复制直接在multi里面实现了；</span></div><div class="line">        multi(a,a,n);<span class="comment">//a=a*a</span></div><div class="line">        n&gt;&gt;=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>res数组初始化就等同于单位矩阵E,最终算出的结果是一个res矩阵。</p>
<h2 id="铜牌爷的写法"><a href="#铜牌爷的写法" class="headerlink" title="铜牌爷的写法"></a>铜牌爷的写法</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct matrix </div><div class="line">&#123; </div><div class="line">    <span class="keyword">ll </span>v[<span class="number">2</span>][<span class="number">2</span>]<span class="comment">; </span></div><div class="line">    matrix() </div><div class="line">    &#123;  </div><div class="line">    memset(v,<span class="number">0</span>,sizeof(v))<span class="comment">; </span></div><div class="line">    &#125; </div><div class="line">    matrix operator *(matrix &amp;t) </div><div class="line">    &#123;  </div><div class="line">        matrix res<span class="comment">;  </span></div><div class="line">        memset(res.v,<span class="number">0</span>,sizeof(res.v))<span class="comment">; </span></div><div class="line">        for(int i=<span class="number">0</span><span class="comment">; i&lt;2; i++)   </span></div><div class="line">            for(int <span class="keyword">j=0; </span><span class="keyword">j&lt;2; </span><span class="keyword">j++) </span>   </div><div class="line">                for(int k=<span class="number">0</span><span class="comment">; k&lt;2; k++)    </span></div><div class="line">                &#123;     </div><div class="line">                    res.v[i][<span class="keyword">j]+=v[i][k]*t.v[k][j]; </span>    </div><div class="line">                    res.v[i][<span class="keyword">j]%=MOD; </span>   </div><div class="line">                &#125;  </div><div class="line">         return res<span class="comment">; </span></div><div class="line">    &#125; </div><div class="line">&#125;<span class="comment">; </span></div><div class="line">matrix power(matrix a,int <span class="keyword">b) </span></div><div class="line">    &#123;</div><div class="line">    matrix ans<span class="comment">;</span></div><div class="line">    memset(ans.v,<span class="number">0</span>,sizeof(ans.v))<span class="comment">;</span></div><div class="line">    ans.v[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span><span class="comment">;</span></div><div class="line">    ans.v[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span><span class="comment">;</span></div><div class="line">    while(<span class="keyword">b&gt;0) </span></div><div class="line">    &#123;</div><div class="line">        if(<span class="keyword">b%2==1)</span></div><div class="line"><span class="keyword"> </span>       &#123;</div><div class="line">            ans*=a<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">b=b&gt;&gt;1;</span></div><div class="line"><span class="keyword"> </span>       a=a*a<span class="comment">;</span></div><div class="line">    &#125; </div><div class="line">    return ans<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于应用。。今天就摸了。。改日<br>可以先看看dalao的应用：</p>
<blockquote>
<p><a href="http://blog.csdn.net/wust_zzwh/article/details/52058209" target="_blank" rel="external">http://blog.csdn.net/wust_zzwh/article/details/52058209</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/05/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/undefined-title/" itemprop="url">输入输出小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T21:28:43+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>emmm图灵杯的简单题可以说是输入的重灾区。。。看了一点紫书的基础部分，还是有必要总结一下cstyle的输入输出函数的。。。</p>
<h2 id="一，scanf-和printf-函数"><a href="#一，scanf-和printf-函数" class="headerlink" title="一，scanf()和printf()函数"></a>一，scanf()和printf()函数</h2><p>Turbo C2.0 标准库提供了两个控制台格式化输入、 输出函数printf() 和scanf(), 这两个函数可以在标准输入输出设备上以各种不同的格式读写数据。printf()函数用来向标准输出设备(屏幕)写数据; scanf() 函数用来从标准输入设备(键盘)上读数据。</p>
<ol>
<li>需要注意I/O变量格式。</li>
<li>输出可以在“%”和字母之间插进数字表示最大场宽。比如保留小数或者前导0。</li>
<li>在scanf函数中出现的标准字符会使得读入时略去这个字符(还有这种操作?)如果特定字符没有找到, scanf()函数就终止。若参数之间的分隔符为空格, 则参数之间必须输入一个或多个空格。</li>
<li>读入时可以在格式化字符串中的“%”各格式化规定符之间加入一个整数, 表示任何读操作中的最大位数。</li>
</ol>
<h2 id="二，puts-和gets-函数"><a href="#二，puts-和gets-函数" class="headerlink" title="二，puts()和gets()函数"></a>二，puts()和gets()函数</h2><ol>
<li>puts()函数puts()函数用来向标准输出设备(屏幕)写字符串并换行, 其调用格式为:puts(s);其中s为字符串变量(字符串数组名或字符串指针)。puts()函数的作用与语printf(”%s\n”, s)相同。</li>
<li>puts()函数只能输出字符串, 不能输出数值或进行格式变换。可以将字符串直接写入puts()函数中。</li>
<li>gets()函数用来从标准输入设备(键盘)读取字符串直到回车结束, 但回车符不属于这个字符串。其调用格式为:gets(s);其中s为字符串变量(字符串数组名或字符串指针)。gets(s)函数与scanf(“%s”, s)相似, 但不完全相同, 使用scanf(“%s”,s)函数输入字符串时存在一个问题, 就是如果输入了空格会认为输入字符串结束,空格后的字符将作为下一个输入项处理, 但gets() 函数将接收输入的整个字符串直到回车为止。</li>
<li>gets(s)函数中的变量s为一字符串。如果为单个字符, 编译不会有错误, 但运行后会出现”Null pointer asignmemt”的错误。而且，gets()函数在读取时不会指明读取的最大字符数，会导致非法内存的出现。因此在c11标准中gets()已被删除。</li>
</ol>
<h2 id="三，putchar-、getch-、getche-和getchar-函数"><a href="#三，putchar-、getch-、getche-和getchar-函数" class="headerlink" title="三，putchar()、getch()、getche()和getchar()函数"></a>三，putchar()、getch()、getche()和getchar()函数</h2><ol>
<li>putchar()函数是向标准输出设备输出一个字符, 其调用格式为:putchar(ch);其中ch为一个字符变量或常量。putchar()函数的作用等同于printf(“%c”, ch);</li>
<li>getch()和getche()函数  这两个函数都是从键盘上读入一个字符。其调用格式为:getch(); getche();两者的区别是:getch()函数不将读入的字符回显在显示屏幕上, 而getche()函数却将读入的字符回显到显示屏幕上。利用回显和不回显的特点, 这两个函数经常用于交互输入的过程中完成暂停等功能。</li>
<li>getchar()函数也是从键盘上读入一个字符, 并带回显。它与前面两个函数的区别在于: getchar()函数等待输入直到按回车才结束, 回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。</li>
</ol>
<h2 id="四，文件的顺序写函数"><a href="#四，文件的顺序写函数" class="headerlink" title="四，文件的顺序写函数"></a>四，文件的顺序写函数</h2><p>fprintf()、fputs()和fputc()函数函数fprintf()、fputs()和fputc()均为文件的顺序写操作函数,其调用格式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *format, &lt;variable-<span class="built_in">list</span>&gt;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, FILE *steam)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *steam)</span></span>;</div></pre></td></tr></table></figure>
<p>上述三个函数的返回值均为整型量。</p>
<ol>
<li>fprintf() 函数的返回值为实际写入文件中的字罕个数(字节数)。如果写错误, 则返回一个负数。</li>
<li>fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时, 表明写操作失败。</li>
<li>fputc()函数返回一个向文件所写字符的值, 此时写操作成功, 否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。</li>
<li>fprintf( ) 函数中格式化的规定与printf( ) 函数相同,   所不同的只是fprintf()函数是向文件中写入。而printf()是向屏幕输出。</li>
</ol>
<h2 id="五，文件的顺序读操作函数"><a href="#五，文件的顺序读操作函数" class="headerlink" title="五，文件的顺序读操作函数"></a>五，文件的顺序读操作函数</h2><p>fscanf()、fgets()和fgetc()函数函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数,其调用格式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *format, &lt;address-<span class="built_in">list</span>&gt;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">int</span> n, FILE *steam)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *steam)</span></span>;</div></pre></td></tr></table></figure>
<ol>
<li>fscanf()函数的用法与scanf()函数相似,   只是它是从文件中读到信息。fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。</li>
<li>fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针,失败返回一个空指针。</li>
<li>fgetc()函数读取一个打开的文件中的一个字符,返回一个int值, 读错误时返回EOF。</li>
</ol>
<h2 id="六，freopen-函数"><a href="#六，freopen-函数" class="headerlink" title="六，freopen ()函数"></a>六，freopen ()函数</h2><ol>
<li><p>函数名：freopen </p>
</li>
<li><p>声明：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FILE</span> *freopen( <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">FILE</span> *stream );</div></pre></td></tr></table></figure>
</li>
<li><p>所在文件： stdio.h</p>
</li>
<li>参数说明：<br>path: 文件名，用于存储输入输出的自定义文件名。<br>mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。<br>stream: 一个文件，通常使用标准流文件。 </li>
<li>返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。（一般可以不使用它的返回值） </li>
<li>功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。 </li>
<li>使用fclose()函数关闭文件。</li>
</ol>
<h2 id="七，sprintf-与sscanf-函数"><a href="#七，sprintf-与sscanf-函数" class="headerlink" title="七，sprintf()与sscanf()函数"></a>七，sprintf()与sscanf()函数</h2><p>1.sprintf()函数    </p>
<p>函数原型为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span>;</div></pre></td></tr></table></figure></p>
<p> 返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。<br> 具体功能：<br> （1）将数字变量转换为字符串。<br> （2）得到整型变量的16进制和8进制字符串。<br> （3）连接多个字符串。</p>
<p>2.sscanf()函数 </p>
<p> sscanf函数原型为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p> 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。<br> 具体功能如下：<br> (1)根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。<br> (2)取指定长度的字符串<br> (3)取到指定字符为止的字符串<br> (4)取仅包含指定字符集的字符串<br> (5)取到指定字符集为止的字符串<br> sscanf可以支持格式字符%[]：<br>(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母<br>(2)^: 表示不取，如：%[^1]表示读取除’1’以外的所有字符 %[^/]表示除/以外的所有字符<br>(3),: 范围可以用”,”相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母<br>(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %<a href="注意^后面有一个空格！">^ </a></p>
<p>3.snprintf()函数</p>
<p> 声明为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span>  format, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出。</p>
<h2 id="番外：c-style的函数"><a href="#番外：c-style的函数" class="headerlink" title="番外：c++style的函数"></a>番外：c++style的函数</h2><ol>
<li><p>cin,cout函数<br>最精简的输入输出方式，傻瓜式操作。同样精简带来的就是不便。。在需要用到各种格式化输出时就要用iomanip头文件中声明的函数来操作。比如setw()函数设置场宽，setprecision()函数设置保留有效数字，setbase()函数以()进制输出。<br>同时效率十分之低。需要用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>); 及 <span class="built_in">cin</span>.tie(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>两个函数关闭和stdin/out的同步来加速。</p>
</li>
<li><p>cin.ignore()函数<br>cin.ignore(a,ch)方法是从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到a或者被抛弃的字符是ch，则cin.ignore()函数执行终止。<br>如果cin.ignore()不给参数，则默认参数为cin.ignore(1,EOF)，即把EOF前的1个字符清掉，没有遇到EOF就清掉一个字符然后结束。</p>
</li>
<li><p>cin.get()函数</p>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ch</span>=cin.get();        或者   cin.<span class="builtin-name">get</span>(ch);</div></pre></td></tr></table></figure>
<p>接收一个字符。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cin.<span class="builtin-name">get</span>(a,20);</div></pre></td></tr></table></figure></p>
<p>接收一个字符串。<br>无参数的cin.get()等同于cin.ignore();</p>
<p><strong>重点来了！！cin.getline()和getline()函数</strong><br>（1）getline()函数 原型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">( istream&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim )</span></span>;</div><div class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">( istream&amp; is, <span class="built_in">string</span>&amp; str )</span></span>;</div></pre></td></tr></table></figure>
<p>读入一行字符。不读入换行符。因为用到了string变量在string头文件中声明。<br>（2）cin.getline()函数 原型为</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssize_t getline(<span class="name">char</span> **lineptr, size_t *n, FILE *stream)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p> cin.getline()实际上有三个参数，cin.getline(接受字符串的变量,接受个数,结束字符)<br>当第三个参数省略时，系统默认为’\0’。不读入换行符。<br>//读空格不读换行符还是挺方便的</p>
<p>参考来源：</p>
<blockquote>
<p><a href="http://blog.csdn.net/wangyin159/article/details/47066247" target="_blank" rel="external">http://blog.csdn.net/wangyin159/article/details/47066247</a><br><a href="http://blog.csdn.net/dingding3w/article/details/46624643" target="_blank" rel="external">http://blog.csdn.net/dingding3w/article/details/46624643</a><br><a href="http://blog.csdn.net/imxiangzi/article/details/45916875" target="_blank" rel="external">http://blog.csdn.net/imxiangzi/article/details/45916875</a><br><a href="http://blog.csdn.net/fenxinzi557/article/details/52222290" target="_blank" rel="external">http://blog.csdn.net/fenxinzi557/article/details/52222290</a><br><a href="http://blog.csdn.net/wxbmelisky/article/details/48596881" target="_blank" rel="external">http://blog.csdn.net/wxbmelisky/article/details/48596881</a><br>《算法竞赛入门经典》by刘汝佳</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ggzero.github.io/2017/12/04/undefined-title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zero.G">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rigid">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/undefined-title/" itemprop="url">neuq 1094</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T20:41:28+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一道简单的字符串应用题。<br><a href="http://newoj.acmclub.cn/problems/1094" target="_blank" rel="external">传送门</a><br>对。是字符串。我们考虑的是如何更高效地解决问题。没必要拘泥于“题意”。//也有可能是我懒得多打几行代码<br>所以我们只要把输入的数字看作字符串就可以很简单地AC了。注意反转后前导0需要跳过即可。<br>同样这道题可以使用stack。伪代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;p;</div><div class="line"><span class="keyword">char</span> c;</div><div class="line"><span class="keyword">while</span>(c==getchar()!=<span class="string">'\0'</span>)    p.push(c);</div><div class="line"><span class="keyword">while</span>(p.top==<span class="string">'0'</span>)    p.pop;</div><div class="line"><span class="keyword">while</span>(!p.empty)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;p.top;    p.pop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这样。祝大家AC愉快。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="zero.G" />
            
              <p class="site-author-name" itemprop="name">zero.G</p>
              <p class="site-description motion-element" itemprop="description">败者无荣耀</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yourname" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zero.G</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
